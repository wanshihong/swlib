## 14. 服务器事件

SWLib 基于 Swoole 服务器事件，提供了完整的事件管理机制。框架通过事件驱动模式处理 HTTP 请求、WebSocket 连接、任务执行等核心功能。

### 14.1 概述

#### 事件驱动架构

Swoole 是一个事件驱动的异步服务器框架，SWLib 在此基础上构建了统一的事件管理系统：

```
┌────────────────────────────────────────────────────────────────┐
│                    Swoole Server                               │
├────────────────────────────────────────────────────────────────┤
│  事件类型                                                       │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐          │
│  │  Start   │ │ Request  │ │  Task    │ │ Shutdown │   ...    │
│  └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘          │
└───────┼────────────┼────────────┼────────────┼─────────────────┘
        │            │            │            │
        ▼            ▼            ▼            ▼
┌────────────────────────────────────────────────────────────────┐
│              ServerEventManager (事件管理器)                    │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              统一事件处理包装器                            │  │
│  │   - 异常捕获                                             │  │
│  │   - 性能监控                                             │  │
│  │   - 日志记录                                             │  │
│  └──────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────────┘
        │
        ▼
┌────────────────────────────────────────────────────────────────┐
│                    事件处理器                                   │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐            │
│  │OnStartEvent  │ │OnRequestEvent│ │OnTaskEvent   │    ...     │
│  └──────────────┘ └──────────────┘ └──────────────┘            │
└────────────────────────────────────────────────────────────────┘
```

#### 支持的事件类型

| 事件 | 处理器 | 说明 | 触发时机 |
|------|--------|------|---------|
| `start` | OnStartEvent | 主进程启动 | 服务器启动时 |
| `workerStart` | OnWorkerStartEvent | Worker 启动 | 每个 Worker 进程启动时 |
| `workerStop` | OnWorkerStopEvent | Worker 停止 | Worker 进程退出时 |
| `request` | OnRequestEvent | HTTP 请求 | 收到 HTTP 请求时 |
| `open` | OnOpenEvent | WebSocket 连接 | WebSocket 连接建立时 |
| `message` | OnMessageEvent | WebSocket 消息 | 收到 WebSocket 消息时 |
| `close` | OnCloseEvent | 连接关闭 | 连接断开时 |
| `task` | OnTaskEvent | 异步任务 | 投递任务时 |
| `finish` | OnFinishEvent | 任务完成 | 任务完成时 |
| `pipeMessage` | OnPipeMessageEvent | 进程通信 | 进程间通信时 |
| `receive` | OnReceiveEvent | TCP 数据 | 收到 TCP 数据时 |
| `shutdown` | OnShutdownEvent | 服务器关闭 | 服务器关闭时 |

---

### 14.2 事件管理器

`ServerEventManager` 是统一的事件管理器，负责绑定和管理所有服务器事件。

#### 事件绑定

框架在启动时自动绑定所有事件：

```php
use Swlib\ServerEvents\ServerEventManager;
use Swoole\Server;

// 自动绑定所有事件（框架内部调用）
ServerEventManager::bindEvents($server);
```

#### 事件处理流程

每个事件都经过统一的处理包装器：

```
1. 记录事件开始时间和内存
2. 执行事件处理器
3. 捕获异常并记录
4. 记录性能统计
5. 记录慢事件警告
```

---

### 14.3 HTTP 请求事件 (OnRequestEvent)

`OnRequestEvent` 是最核心的事件处理器，处理所有 HTTP 请求。

#### 处理流程

```
HTTP 请求
    │
    ▼
┌─────────────────┐
│ 设置 CORS 头    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ OPTIONS 预检?   │─── 是 ───▶ 返回空响应
└────────┬────────┘
         │ 否
         ▼
┌─────────────────┐
│ favicon.ico?    │─── 是 ───▶ 返回空响应
└────────┬────────┘
         │ 否
         ▼
┌─────────────────┐
│ 解析路由        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 检查访问权限    │─── 失败 ──▶ 拒绝请求
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 合并 PathInfo   │
│ 和 Query 参数   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 检查请求方法    │─── 不匹配 ─▶ 405 错误
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 保存协程上下文  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 执行路由控制器  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 返回响应        │
└─────────────────┘
```

#### CORS 配置

框架默认支持跨域请求：

```php
// 默认 CORS 头
'Access-Control-Allow-Origin' => '*',
'Access-Control-Allow-Methods' => 'GET, POST, OPTIONS',
'Access-Control-Allow-Credentials' => 'true',
'Access-Control-Allow-Headers' => '*',
'Access-Control-Expose-Headers' => 'random,time,token,...'
```

#### 协程上下文

每个请求都会保存以下上下文信息：

```php
use Swlib\Enum\CtxEnum;

// 在请求处理过程中可随时获取
$uri = CtxEnum::URI->get();           // 请求 URI
$workerId = CtxEnum::WorkerId->get(); // Worker ID
$request = CtxEnum::Request->get();   // Request 对象
$response = CtxEnum::Response->get(); // Response 对象
$server = CtxEnum::Server->get();     // Server 对象
$requestId = CtxEnum::RequestId->get(); // 请求唯一 ID
$lang = CtxEnum::Lang->get();         // 语言设置
```

#### 请求 ID

每个请求都会生成唯一的 request-id，便于日志追踪：

```php
// 响应头中包含
response-header: request-id: 5f3a8b2c1e9d4a6f7b8c9d0e
```

---

### 14.4 Worker 启动事件 (OnWorkerStartEvent)

每个 Worker 进程启动时触发，用于初始化进程级别的资源。

#### 处理内容

```php
class OnWorkerStartEvent
{
    public function handle(Server $server, int $workerId): void
    {
        // 1. 保存 Worker 信息到管理器
        WorkerManager::set("workerId", $workerId);
        WorkerManager::set("server", $server);

        // 2. 启动数据库心跳检测
        MysqlHeart::start();
        RedisHeart::start();

        // 3. 注册自定义事件监听
        Event::onMaps();

        // 4. 触发 Worker 启动事件
        EventEnum::ServerWorkerStartEvent->emit([...]);
    }
}
```

#### 输出信息

```
WorkerStart:0 pid:12345 posix_getpid:12345
WorkerStart:1 pid:12346 posix_getpid:12346
taskWorkerStart:0 pid:12347 posix_getpid:12347
```

---

### 14.5 服务器启动事件 (OnStartEvent)

主进程启动时触发，用于输出版本信息和初始化全局资源。

#### 启动输出

```
✔ 服务器启动成功
http://127.0.0.1:9501
http://192.168.1.100:9501
扩展 protobuf 字段工具: http://192.168.1.100:9501/dev-tool/protobuf-ext-editor/index
管理后台地址: http://192.168.1.100:9501/admin/dashboard/index
```

#### 处理内容

```php
class OnStartEvent
{
    public function handle(Server $server): void
    {
        // 1. 触发服务器启动事件
        EventEnum::ServerStartEvent->emit(['server' => $server]);

        // 2. 输出可访问地址
        // 3. 输出开发工具地址
        // 4. 输出管理后台地址
        // 5. 确保超级管理员存在（开发环境）
    }
}
```

---

### 14.6 WebSocket 事件

#### 连接建立 (OnOpenEvent)

```php
class OnOpenEvent
{
    public function handle(Server $server, $frame): void
    {
        // WebSocket 连接建立时的处理
        // 可用于：用户认证、连接记录等
    }
}
```

#### 消息接收 (OnMessageEvent)

```php
class OnMessageEvent
{
    public function handle(Server $server, $frame): void
    {
        // 处理 WebSocket 消息
        // $frame->data 包含消息内容
        // $frame->fd 是连接标识
    }
}
```

#### 连接关闭 (OnCloseEvent)

```php
class OnCloseEvent
{
    public function handle(Server $server, int $fd): void
    {
        // 连接关闭时的清理工作
    }
}
```

---

### 14.7 任务事件

#### 任务执行 (OnTaskEvent)

```php
class OnTaskEvent
{
    public function handle(Server $server, int $taskId, int $srcWorkerId, mixed $data): void
    {
        // 执行异步任务
        // $taskId: 任务 ID
        // $srcWorkerId: 投递任务的 Worker ID
        // $data: 任务数据
    }
}
```

#### 任务完成 (OnFinishEvent)

```php
class OnFinishEvent
{
    public function handle(Server $server, int $taskId, mixed $data): void
    {
        // 任务完成后的处理
        // $data 是 OnTaskEvent 的返回值
    }
}
```

---

### 14.8 性能监控

`EventPerformanceMonitor` 提供事件执行的详细性能统计。

#### 自动监控

所有事件都会自动记录性能数据：

```php
// 事件执行时自动记录
- 执行次数
- 总耗时
- 平均耗时
- 最大/最小耗时
- 错误次数
- 错误率
```

#### 慢事件警告

当事件执行超过 100ms 时，会记录慢事件警告：

```
[WARNING] Slow event detected
{
    "event": "request",
    "execution_time": "150.25ms",
    "memory_used": "2.5 MB",
    "memory_peak": "10.2 MB",
    "trace_id": "request_65a1b2c3d4e5f6"
}
```

#### 获取性能报告

```php
use Swlib\ServerEvents\EventPerformanceMonitor;

// 获取所有事件的性能统计
$stats = EventPerformanceMonitor::getStats();

// 获取特定事件的统计
$requestStats = EventPerformanceMonitor::getStats('request');

// 获取格式化的性能报告
$report = EventPerformanceMonitor::getReport();
```

#### 性能报告示例

```
Event Performance Report
========================

Event: request
  Count: 1000
  Avg Time: 15.25ms
  Max Time: 150.25ms
  Min Time: 2.10ms
  Total Time: 15250.00ms
  Errors: 5 (0.50%)

Event: task
  Count: 100
  Avg Time: 50.10ms
  Max Time: 200.50ms
  Min Time: 10.00ms
  Total Time: 5010.00ms
  Errors: 0 (0.00%)
```

---

### 14.9 自定义事件监听

框架通过事件系统支持自定义事件监听。

#### 监听框架事件

```php
use Swlib\Event\EventEnum;

// 监听 HTTP 请求事件
EventEnum::HttpRequestEvent->addListener(function ($data) {
    $request = $data['request'];
    $response = $data['response'];
    // 自定义处理逻辑
});

// 监听路由进入事件
EventEnum::HttpRouteEnterEvent->addListener(function ($data) {
    $uri = $data['uri'];
    $ip = $data['ip'];
    Log::info("请求进入", ['uri' => $uri, 'ip' => $ip]);
});

// 监听 Worker 启动事件
EventEnum::ServerWorkerStartEvent->addListener(function ($data) {
    $workerId = $data['workerId'];
    // Worker 启动后的初始化
});
```

#### 可用的事件类型

| 事件枚举 | 说明 |
|---------|------|
| `HttpRequestEvent` | HTTP 请求到达 |
| `HttpRouteEnterEvent` | 路由进入 |
| `ServerStartEvent` | 服务器启动 |
| `ServerWorkerStartEvent` | Worker 启动 |
| `DatabaseTransactionEvent` | 数据库事务 |

---

### 14.10 最佳实践

#### 避免阻塞事件处理

```php
// 不推荐：在事件处理中执行耗时操作
public function handle(Request $request, Response $response): void
{
    sleep(10);  // 阻塞整个 Worker
}

// 推荐：使用 Task 异步处理
public function handle(Request $request, Response $response): void
{
    $server->task(['action' => 'heavy_work']);
}
```

#### 异常处理

```php
// 事件处理中的异常会被自动捕获和记录
// 但对于关键事件，异常会被重新抛出
try {
    $handler->handle(...$args);
} catch (Throwable $e) {
    Log::saveException($e, "Event '$eventName' failed");
    // start、workerStart、shutdown 事件会重新抛出异常
    if (in_array($eventName, ['start', 'workerStart', 'shutdown'])) {
        throw $e;
    }
}
```

#### 性能优化

```php
// 1. 避免在热路径中创建对象
// 2. 使用连接池而不是频繁创建连接
// 3. 合理使用缓存
// 4. 监控慢事件并优化
```

---

### 14.11 API 参考

#### ServerEventManager

| 方法 | 参数 | 返回值 | 说明 |
|------|------|--------|------|
| `bindEvents(server)` | Server $server | void | 绑定所有服务器事件 |
| `clearInstanceCache()` | - | void | 清理处理器实例缓存 |

#### EventPerformanceMonitor

| 方法 | 参数 | 返回值 | 说明 |
|------|------|--------|------|
| `startEvent(eventName)` | string $eventName | string | 记录事件开始，返回 traceId |
| `endEvent(traceId, hasError)` | string, bool | void | 记录事件结束 |
| `getStats(eventName)` | ?string $eventName | array | 获取性能统计 |
| `resetStats()` | - | void | 重置统计数据 |
| `getReport()` | - | string | 获取格式化报告 |

#### 事件处理器接口

所有事件处理器都实现 `handle()` 方法：

```php
interface EventHandlerInterface
{
    public function handle(...$args): void;
}
```
