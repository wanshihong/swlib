## 12. 锁机制

框架提供了两种锁机制：**Worker 进程锁**（单进程内有效）和 **Redis 分布式锁**（跨进程/跨服务器有效）。

### 12.1 Redis 分布式锁

Redis 锁使用 Redis SET 命令的 NX 和 PX 选项实现，支持跨进程/跨服务器的分布式锁。

#### 方式一：使用注解（推荐）

```php
use Swlib\Lock\Attribute\RedisLockAttribute;

class UserService
{
    #[RedisLockAttribute(
        keyTemplate: 'userId',     // 使用 $userId 参数作为锁标识
        ttl: 5000,                  // 锁超时时间（毫秒），默认10000ms
        retryCount: 3,              // 获取锁失败重试次数，默认3次
        retryDelay: 200             // 重试间隔（毫秒），默认200ms
    )]
    public static function updateUser(int $userId, string $data): void
    {
        // 方法执行期间持有锁
        $user = new UserTable()->where([UserTable::ID => $userId])->selectOne();
        $user->data = $data;
        $user->__save();
    }
}

// 调用：正常调用即可，代理会自动加锁和解锁
UserService::updateUser($userId, $data);
```

**锁 Key 生成规则：**

| keyTemplate | 生成的 Key |
|-------------|-----------|
| `'userId'` | `UserService::updateUser:123` |
| `null` 或不设置 | `UserService::updateUser:[md5参数]` |

#### 方式二：手动调用

```php
use Swlib\Lock\RedisLock;

// 基本用法
$lockValue = RedisLock::lock('user_lock_key', 10000);  // 10秒超时
if ($lockValue) {
    try {
        // 执行业务逻辑
        $this->criticalOperation();
    } finally {
        RedisLock::unlock('user_lock_key', $lockValue);
    }
}

// 使用 withLock 自动管理
RedisLock::withLock(
    lockKey: 'user_lock_key',
    callback: function ($lockValue) {
        // 业务逻辑
        $this->criticalOperation();
    },
    ttl: 10000,              // 锁超时时间（毫秒）
    retryCount: 3,           // 获取锁失败重试次数
    retryDelay: 200,         // 重试间隔（毫秒）
    autoRenew: true          // 自动续期
);
```

#### 续期锁

```php
// 手动续期
RedisLock::renew('user_lock_key', $lockValue, 10000);
```

### 12.2 Worker 进程锁

Worker 锁只在单个进程内有效，适合进程内协程间的同步。

#### 方式一：使用注解（推荐）

```php
use Swlib\Lock\Attribute\WorkerLockAttribute;

class DataProcessService
{
    #[WorkerLockAttribute(
        keyTemplate: 'batchId',    // 使用 $batchId 参数作为锁标识
        timeout: 3000,               // 获取锁超时时间（毫秒），默认3000ms
        ttl: 60000,                  // 锁的有效期（毫秒），默认60000ms
        retryCount: 3,               // 获取锁失败重试次数，默认3次
        retryDelay: 200              // 重试间隔（毫秒），默认200ms
    )]
    public static function processBatch(int $batchId): void
    {
        // 同一 Worker 内同一时间只有一个协程能执行此方法
        // 处理批次数据
        self::doProcess($batchId);
    }
}

// 调用：正常调用即可
DataProcessService::processBatch($batchId);
```

#### 方式二：手动调用

```php
use Swlib\Lock\WorkerLock;

// 基本用法
$lockValue = WorkerLock::lock('data_process', 3000, 60000);
if ($lockValue) {
    try {
        // 执行业务逻辑
        $this->criticalOperation();
    } finally {
        WorkerLock::unlock('data_process', $lockValue);
    }
}

// 使用 withLock 自动管理
WorkerLock::withLock(
    lockKey: 'data_process',
    callback: function ($lockValue) {
        // 业务逻辑
        $this->criticalOperation();
    },
    timeout: 3000,            // 获取锁超时时间（毫秒）
    ttl: 60000,              // 锁的有效期（毫秒）
    retryCount: 3,           // 获取锁失败重试次数
    retryDelay: 200,         // 重试间隔（毫秒）
    autoRenew: false         // 自动续期
);
```

### 12.3 注解参数对比

| 参数 | RedisLockAttribute | WorkerLockAttribute | 说明 |
|------|-------------------|---------------------|------|
| `keyTemplate` | string\|null | string\|null | 使用方法参数名作为锁标识 |
| `ttl/timeout` | int (毫秒) | int (毫秒) | 锁超时时间，**统一使用毫秒** |
| `retryCount` | int | int | 获取锁失败重试次数 |
| `retryDelay` | int (毫秒) | int (毫秒) | 重试间隔，**统一使用毫秒** |
| `priority` | int | int | 代理优先级 |
| `async` | bool | bool | 是否异步执行 |

### 12.4 锁的对比

| 特性 | Redis 分布式锁 | Worker 进程锁 |
|------|----------------|---------------|
| 作用范围 | 跨进程、跨服务器 | 单个 Worker 进程内 |
| 存储 | Redis | Worker 内存 |
| 性能 | 较低（网络IO） | 较高（内存操作） |
| 适用场景 | 多进程/多服务器共享资源 | 进程内协程同步 |
| 时间单位 | **毫秒** | **毫秒** |

### 12.5 使用建议

1. **需要跨进程加锁** → 使用 `RedisLock`
   ```php
   #[RedisLockAttribute(keyTemplate: 'orderId')]
   public static function processOrder(int $orderId): void
   ```

2. **进程内防重复执行** → 使用 `WorkerLock`
   ```php
   #[WorkerLockAttribute(keyTemplate: 'batchId')]
   public static function processBatch(int $batchId): void
   ```

3. **keyTemplate 为 null** → 使用所有参数的 MD5 值作为锁标识
   ```php
   #[RedisLockAttribute]  // keyTemplate 默认为 null
   public static function complexOperation(int $a, string $b, array $c): void
   // 锁 Key: ClassName::complexOperation:[md5(参数)]
   ```

4. **长时间任务** → 启用 `autoRenew` 自动续期
   ```php
   RedisLock::withLock(
       lockKey: 'long_task',
       callback: fn() => $this->longRunningTask(),
       autoRenew: true  // 自动续期，防止任务执行期间锁过期
   );
   ```

### 12.6 完整示例

```php
use Swlib\Lock\Attribute\RedisLockAttribute;
use Swlib\Lock\Attribute\WorkerLockAttribute;

class OrderService
{
    // Redis 分布式锁：防止多进程同时处理同一订单
    #[RedisLockAttribute(
        keyTemplate: 'orderId',
        ttl: 30000,      // 30秒超时（30000毫秒）
        retryCount: 5,    // 重试5次
        retryDelay: 500   // 重试间隔500毫秒
    )]
    public static function processOrder(int $orderId): void
    {
        $order = new OrderTable()->where([OrderTable::ID => $orderId])->selectOne();

        // 更新订单状态
        new OrderTable()->where([OrderTable::ID => $orderId])->update([
            OrderTable::STATUS => 'processing'
        ]);

        // 处理订单逻辑...
    }

    // Worker 进程锁：防止同一进程内重复处理批次
    #[WorkerLockAttribute(
        keyTemplate: 'batchId',
        timeout: 5000,    // 等待锁5秒（5000毫秒）
        ttl: 120000        // 锁定120秒（120000毫秒）
    )]
    public static function processBatchData(int $batchId): void
    {
        // 处理批次数据，同一 Worker 内不会重复执行
        $items = new BatchItemTable()
            ->where([BatchItemTable::BATCH_ID => $batchId])
            ->selectAll();

        foreach ($items as $item) {
            self::processItem($item);
        }
    }
}
```
