## 9. 定时任务

SWLib 提供了基于 Cron 表达式的定时任务调度系统，支持精确的时间控制、协程执行、超时设置和防重复执行。

### 9.1 概述

#### 调度器架构

```
┌─────────────────────────────────────────────────────────────────┐
│                    CrontabScheduler                             │
│                    (独立进程运行)                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  主循环 (每秒检查)                        │   │
│  │                                                          │   │
│  │   foreach (CrontabMap::TASKS as $task) {                │   │
│  │       if (任务到期?) {                                   │   │
│  │           if (允许协程?) {                               │   │
│  │               Coroutine::create(executeTask);           │   │
│  │           } else {                                       │   │
│  │               executeTask();                             │   │
│  │           }                                              │   │
│  │       }                                                  │   │
│  │   }                                                      │   │
│  │                                                          │   │
│  │   System::sleep(1);  // 等待 1 秒                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 特性

- **标准 Cron 表达式** - 支持 5 字段标准格式
- **防重复执行** - 同一分钟内同一任务只执行一次
- **协程支持** - 任务可在独立协程中执行
- **超时控制** - 可设置任务执行超时时间
- **异常处理** - 自动捕获并记录异常
- **执行日志** - 记录任务开始、完成、失败状态

---

### 9.2 创建定时任务

#### 基本用法

```php
use Swlib\Crontab\Attribute\CrontabAttribute;

#[CrontabAttribute(
    cron: '0 * * * *',       // Cron 表达式
    timeout: 300,            // 超时时间（秒）
    enable_coroutine: true,  // 启用协程
    name: 'hourly_statistics' // 任务名称（可选）
)]
class HourlyStatisticsTask
{
    public function run($server): void
    {
        // 执行统计任务
        $this->calculateStatistics();
    }

    private function calculateStatistics(): void
    {
        // 统计逻辑
    }
}
```

#### 使用类方法

```php
use Swlib\Crontab\Attribute\CrontabAttribute;

class StatisticsTasks
{
    #[CrontabAttribute(cron: '0 * * * *', name: 'hourly_stats')]
    public function hourlyStatistics($server): void
    {
        // 每小时统计
    }

    #[CrontabAttribute(cron: '0 0 * * *', name: 'daily_cleanup')]
    public function dailyCleanup($server): void
    {
        // 每天凌晨清理
    }

    #[CrontabAttribute(cron: '0 0 * * 0', name: 'weekly_report')]
    public function weeklyReport($server): void
    {
        // 每周报告
    }
}
```

---

### 9.3 Cron 表达式

#### 格式说明

```
┌───────────── 分钟 (0-59)
│ ┌───────────── 小时 (0-23)
│ │ ┌───────────── 日期 (1-31)
│ │ │ ┌───────────── 月份 (1-12)
│ │ │ │ ┌───────────── 星期 (0-6, 0=周日)
│ │ │ │ │
* * * * *
```

#### 支持的特殊字符

| 字符 | 说明 | 示例 |
|------|------|------|
| `*` | 任意值 | `* * * * *` = 每分钟 |
| `,` | 列表 | `0,30 * * * *` = 每小时的 0分和30分 |
| `-` | 范围 | `0 9-17 * * *` = 9点到17点每小时 |
| `/` | 步长 | `*/5 * * * *` = 每5分钟 |

#### 常用表达式

| 表达式 | 说明 |
|--------|------|
| `* * * * *` | 每分钟执行 |
| `*/5 * * * *` | 每5分钟执行 |
| `0 * * * *` | 每小时整点执行 |
| `0 */2 * * *` | 每2小时执行 |
| `0 0 * * *` | 每天午夜 00:00 执行 |
| `0 9 * * *` | 每天早上 9:00 执行 |
| `0 9,18 * * *` | 每天 9:00 和 18:00 执行 |
| `0 9-17 * * *` | 每天 9:00 到 17:00 每小时执行 |
| `0 0 * * 0` | 每周日午夜执行 |
| `0 0 * * 1` | 每周一午夜执行 |
| `0 0 * * 1-5` | 每个工作日午夜执行 |
| `0 0 1 * *` | 每月1号午夜执行 |
| `0 0 1 1 *` | 每年1月1号午夜执行 |

#### 业务场景示例

```php
// 1. 每小时数据统计
#[CrontabAttribute(cron: '0 * * * *')]
class HourlyStatistics { }

// 2. 每天 9 点发送早报
#[CrontabAttribute(cron: '0 9 * * *')]
class MorningReport { }

// 3. 每天午夜清理过期数据
#[CrontabAttribute(cron: '0 0 * * *')]
class DailyCleanup { }

// 4. 每周一 10 点生成周报
#[CrontabAttribute(cron: '0 10 * * 1')]
class WeeklyReport { }

// 5. 每月 1 号统计月度数据
#[CrontabAttribute(cron: '0 0 1 * *')]
class MonthlyStatistics { }

// 6. 工作日 9-18 点每小时检查
#[CrontabAttribute(cron: '0 9-18 * * 1-5')]
class WorkingHoursCheck { }

// 7. 每 5 分钟心跳检测
#[CrontabAttribute(cron: '*/5 * * * *')]
class Heartbeat { }

// 8. 每天 12 点和 18 点推送
#[CrontabAttribute(cron: '0 12,18 * * *')]
class ScheduledPush { }
```

---

### 9.4 任务配置参数

#### CrontabAttribute 参数

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `cron` | string | 必填 | Cron 表达式 |
| `timeout` | int | 300 | 超时时间（秒），0 表示无限制 |
| `enable_coroutine` | bool | true | 是否在协程中执行 |
| `name` | string | '' | 任务名称，默认使用 `类名::方法名` |

#### 超时设置

```php
// 短任务：30秒超时
#[CrontabAttribute(cron: '*/5 * * * *', timeout: 30)]
class QuickCheck { }

// 中等任务：5分钟超时
#[CrontabAttribute(cron: '0 * * * *', timeout: 300)]
class NormalTask { }

// 长任务：30分钟超时
#[CrontabAttribute(cron: '0 0 * * *', timeout: 1800)]
class LongRunningTask { }

// 无超时限制
#[CrontabAttribute(cron: '0 0 1 * *', timeout: 0)]
class NoTimeoutTask { }
```

---

### 9.5 实际应用示例

#### 数据清理任务

```php
use Swlib\Crontab\Attribute\CrontabAttribute;
use Generate\Tables\UserLoginHisTable;
use Swlib\Utils\Log;

#[CrontabAttribute(
    cron: '0 0 * * *',        // 每天午夜执行
    timeout: 600,             // 10分钟超时
    name: 'cleanup_expired_data'
)]
class DataCleanupTask
{
    public function run($server): void
    {
        Log::info('开始清理过期数据');

        // 1. 清理 90 天前的登录日志
        $deleted = new UserLoginHisTable()
            ->where([
                [UserLoginHisTable::CREATED_AT, '<', strtotime('-90 days')]
            ])
            ->delete();

        Log::info('登录日志清理完成', ['deleted' => $deleted]);

        // 2. 清理过期缓存
        $this->clearExpiredCache();

        // 3. 清理临时文件
        $this->clearTempFiles();

        Log::info('过期数据清理完成');
    }

    private function clearExpiredCache(): void
    {
        // 清理逻辑
    }

    private function clearTempFiles(): void
    {
        // 清理逻辑
    }
}
```

#### 统计任务

```php
use Swlib\Crontab\Attribute\CrontabAttribute;
use Generate\Tables\OrderTable;
use Generate\Tables\StatisticsTable;
use Swlib\Utils\Log;

#[CrontabAttribute(
    cron: '0 * * * *',        // 每小时执行
    timeout: 300
)]
class HourlyStatisticsTask
{
    public function run($server): void
    {
        $hour = date('Y-m-d H:00:00', strtotime('-1 hour'));

        // 统计上一小时的订单数据
        $stats = new OrderTable()
            ->field([
                'COUNT(*) as total_orders',
                'SUM(total_amount) as total_amount',
                'AVG(total_amount) as avg_amount'
            ])
            ->where([
                [OrderTable::CREATED_AT, '>=', strtotime($hour)],
                [OrderTable::CREATED_AT, '<', strtotime('+1 hour', strtotime($hour))]
            ])
            ->selectOne();

        // 保存统计结果
        new StatisticsTable()->insert([
            StatisticsTable::PERIOD => $hour,
            StatisticsTable::TOTAL_ORDERS => $stats->totalOrders,
            StatisticsTable::TOTAL_AMOUNT => $stats->totalAmount,
            StatisticsTable::AVG_AMOUNT => $stats->avgAmount,
            StatisticsTable::CREATED_AT => time()
        ]);

        Log::info('小时统计完成', [
            'period' => $hour,
            'orders' => $stats->totalOrders
        ]);
    }
}
```

#### 消息推送任务

```php
use Swlib\Crontab\Attribute\CrontabAttribute;
use Generate\Tables\UserTable;
use Generate\Tables\PushNotificationTable;
use Swlib\Connect\PoolRedis;
use Swlib\Utils\Log;

#[CrontabAttribute(
    cron: '*/5 * * * *',      // 每5分钟检查
    timeout: 60,
    enable_coroutine: true
)]
class PushNotificationTask
{
    public function run($server): void
    {
        // 获取待推送的消息
        $notifications = new PushNotificationTable()
            ->where([
                PushNotificationTable::STATUS => 0,
                [PushNotificationTable::SCHEDULED_AT, '<=', time()]
            ])
            ->page(1, 100)
            ->selectAll();

        foreach ($notifications as $notification) {
            try {
                $this->sendPush($notification);

                // 更新状态为已发送
                new PushNotificationTable()
                    ->where([PushNotificationTable::ID => $notification->id])
                    ->update([
                        PushNotificationTable::STATUS => 1,
                        PushNotificationTable::SENT_AT => time()
                    ]);

            } catch (Throwable $e) {
                Log::error('推送失败', [
                    'notification_id' => $notification->id,
                    'error' => $e->getMessage()
                ]);
            }
        }
    }

    private function sendPush($notification): void
    {
        // 推送逻辑
    }
}
```

---

### 9.6 任务执行机制

#### 防重复执行

框架确保同一分钟内同一任务只执行一次：

```php
// 框架内部实现
private array $lastExecuted = [];

private function checkAndExecuteTasks($server, DateTime $now): void
{
    foreach (CrontabMap::TASKS as $task) {
        $taskId = $task['run'][0] . '::' . $task['run'][1];

        // 检查是否已执行
        $currentMinute = $now->format('Y-m-d H:i');
        if (isset($this->lastExecuted[$taskId]) &&
            $this->lastExecuted[$taskId] === $currentMinute) {
            continue;  // 跳过已执行的任务
        }

        // 记录执行时间
        $this->lastExecuted[$taskId] = $currentMinute;

        // 执行任务
        // ...
    }
}
```

#### 协程执行

当 `enable_coroutine: true` 时，任务在独立协程中执行：

```php
// 创建协程执行任务
if ($task['enable_coroutine']) {
    Coroutine::create(function () use ($task, $server, $taskId) {
        $this->executeTask($task, $server, $taskId);
    });
} else {
    $this->executeTask($task, $server, $taskId);
}
```

#### 超时控制

使用 Swoole Timer 实现超时控制：

```php
private function executeTask(array $task, $server, string $taskId): void
{
    $timeout = $task['timeout'] ?? 300;

    if ($timeout > 0 && Coroutine::getCid() > 0) {
        $timerId = Timer::after($timeout * 1000, function () use ($taskId, $timeout) {
            Log::error("Task timeout: $taskId (timeout: {$timeout}s)");
        });

        try {
            $instance->$methodName($server);
        } finally {
            Timer::clear($timerId);
        }
    }
}
```

---

### 9.7 任务日志

#### 自动日志

框架自动记录任务的开始、完成和失败：

```
[INFO] Task started: DataCleanupTask::run
[INFO] Task completed: DataCleanupTask::run (1234.56ms)
[ERROR] Task failed: DataCleanupTask::run (500.12ms) - 数据库连接超时
[ERROR] Task timeout: LongRunningTask::run (timeout: 300s)
```

#### 自定义日志

```php
#[CrontabAttribute(cron: '0 * * * *')]
class MonitoredTask
{
    public function run($server): void
    {
        $startTime = microtime(true);

        Log::info('任务开始', ['task' => __CLASS__]);

        try {
            $result = $this->doWork();

            $duration = round((microtime(true) - $startTime) * 1000, 2);
            Log::info('任务完成', [
                'duration' => $duration . 'ms',
                'result' => $result
            ]);

        } catch (Throwable $e) {
            Log::error('任务失败', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
        }
    }
}
```

---

### 9.8 最佳实践

#### 任务幂等性

```php
// 推荐：任务可以安全地重复执行
#[CrontabAttribute(cron: '*/5 * * * *')]
class IdempotentTask
{
    public function run($server): void
    {
        // 使用状态标记避免重复处理
        $items = new OrderTable()
            ->where([
                OrderTable::STATUS => OrderTable::STATUS_PENDING,
                OrderTable::PROCESS_LOCK => 0
            ])
            ->lock()
            ->selectOne();

        if ($items) {
            // 处理并更新状态
        }
    }
}
```

#### 任务拆分

```php
// 不推荐：一个大任务处理所有数据
#[CrontabAttribute(cron: '0 0 * * *')]
class BadDailyTask
{
    public function run($server): void
    {
        $users = new UserTable()->selectAll();  // 可能很多
        foreach ($users as $user) {
            $this->processUser($user);  // 逐个处理
        }
    }
}

// 推荐：分批处理
#[CrontabAttribute(cron: '0 0 * * *')]
class GoodDailyTask
{
    public function run($server): void
    {
        $page = 1;
        $pageSize = 100;

        while (true) {
            $users = new UserTable()
                ->where([UserTable::NEED_PROCESS => 1])
                ->page($page, $pageSize)
                ->selectAll();

            if (empty($users->__rows)) {
                break;
            }

            foreach ($users as $user) {
                $this->processUser($user);
            }

            $page++;
        }
    }
}
```

#### 异常处理

```php
#[CrontabAttribute(cron: '0 * * * *')]
class SafeTask
{
    public function run($server): void
    {
        // 整体异常捕获
        try {
            $this->doWork();
        } catch (Throwable $e) {
            Log::saveException($e, 'crontab');
            // 不要抛出异常，让调度器继续运行
        }
    }

    private function doWork(): void
    {
        $items = $this->getItems();

        foreach ($items as $item) {
            try {
                $this->processItem($item);
            } catch (Throwable $e) {
                // 单个项目失败不影响其他项目
                Log::error('处理失败', [
                    'item_id' => $item->id,
                    'error' => $e->getMessage()
                ]);
            }
        }
    }
}
```

#### 合理设置超时

```php
// 根据任务预期执行时间设置超时
#[CrontabAttribute(cron: '*/5 * * * *', timeout: 60)]   // 快速检查：1分钟
class QuickCheck { }

#[CrontabAttribute(cron: '0 * * * *', timeout: 300)]    // 常规任务：5分钟
class RegularTask { }

#[CrontabAttribute(cron: '0 0 * * *', timeout: 1800)]  // 日常任务：30分钟
class DailyTask { }
```

---

### 9.9 调试与监控

#### 查看定时任务列表

```php
// 定时任务配置在运行时生成
// 位置：runtime/Generate/CrontabMap.php

// 查看已注册的任务
$tasks = CrontabMap::TASKS;
```

#### 手动触发测试

```php
// 创建测试路由
#[Router(method: 'POST')]
public function testCron(): JsonResponse
{
    $task = new DataCleanupTask();
    $task->run($this->server);

    return JsonResponse::success('任务执行完成');
}
```

#### 监控任务执行

```bash
# 查看定时任务日志
tail -f runtime/log/*/crontab.log
```

---

### 9.10 API 参考

#### CrontabAttribute 注解

```php
namespace Swlib\Crontab\Attribute;

#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
class CrontabAttribute
{
    public function __construct(
        public string $cron,            // Cron 表达式（必需）
        public int    $timeout = 300,   // 超时时间（秒）
        public bool   $enable_coroutine = true,
        public string $name = ''
    ) {}
}
```

#### CronExpression 类

```php
namespace Swlib\Crontab;

class CronExpression
{
    public function __construct(string $expression) {}

    // 判断给定时间是否应该执行
    public function isDue(DateTime $now): bool {}
}
```

#### CrontabScheduler 类

| 方法 | 说明 |
|------|------|
| `run($server)` | 静态方法，启动调度器进程 |

---

### 9.11 定时任务 vs 自定义进程

| 特性 | 定时任务 (Crontab) | 自定义进程 (Process) |
|------|-------------------|---------------------|
| 执行方式 | 按时间点执行 | 循环执行 |
| 时间精度 | 分钟级 | 毫秒级 |
| 适用场景 | 定时报表、清理、统计 | 消费队列、监控、推送 |
| 防重复 | 自动防止 | 需手动实现 |
| 调度 | 单进程多协程 | 独立进程 |

```php
// 定时任务：适合固定时间点的任务
#[CrontabAttribute(cron: '0 9 * * *')]  // 每天 9 点
class DailyReport { }

// 自定义进程：适合持续运行的任务
#[ProcessAttribute(interval: 100)]  // 每 100ms 检查
class QueueConsumer { }
```
