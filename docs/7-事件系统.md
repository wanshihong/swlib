## 7. 事件系统

SWLib 提供了强大的事件系统，支持同步/异步事件处理、优先级、延迟执行、队列等特性。

### 7.1 内置事件

框架通过 `EventEnum` 定义了以下内置事件：

| 事件枚举 | 说明 | 触发时机 |
|---------|------|----------|
| `OnParseRouterEvent` | 路由解析完成 | 路由解析后 |
| `ServerStartEvent` | 服务器启动 | Swoole 服务器启动时 |
| `ServerWorkerStartEvent` | Worker 启动 | Worker 进程启动时 |
| `ServerWorkerStopEvent` | Worker 停止 | Worker 进程停止时 |
| `ServerShutdownEvent` | 服务器关闭 | 服务器关闭时 |
| `ServerTaskEvent` | Task 任务 | Task 进程收到任务时 |
| `WebSocketOnOpenEvent` | WebSocket 连接 | WebSocket 连接建立 |
| `WebSocketOnMessageEvent` | WebSocket 消息 | 收到 WebSocket 消息 |
| `HttpRouteEnterEvent` | HTTP 路由进入 | HTTP 路由开始处理 |
| `DatabaseBeforeExecuteEvent` | 数据库操作前 | 数据库操作执行前 |
| `DatabaseAfterExecuteEvent` | 数据库操作后 | 数据库操作执行后 |
| `DatabaseTransactionEvent` | 数据库事务 | 事务开始/提交/回滚 |

### 7.2 定义事件监听器

使用 `#[Event]` 注解定义事件监听器：

```php
use Swlib\Event\Attribute\Event;

#[Event(
    name: 'user.registered',     // 事件名称
    priority: 10                  // 优先级（数字越小优先级越高，默认10）
)]
class SendWelcomeEmailListener
{
    public function run(array $data): void
    {
        $userId = $data['userId'];
        $username = $data['username'];
        $email = $data['email'];

        // 发送欢迎邮件
        EmailService::send($email, '欢迎注册', "欢迎 {$username} 注册！");
    }
}
```

**`#[Event]` 注解参数：**

| 参数 | 类型 | 说明 |
|------|------|------|
| `name` | string | 事件名称 |
| `priority` | int | 优先级，数字越小越先执行（默认10） |

### 7.3 触发事件

#### 基本用法

```php
use Swlib\Event\EventEnum;

// 使用内置事件枚举
EventEnum::ServerStartEvent->emit([
    'server' => $server,
    'timestamp' => time()
]);

// 触发自定义事件
Event::emit('user.registered', [
    'userId' => $userId,
    'username' => $username,
    'email' => $email
]);
```

#### 事件执行模式

`Event::emit()` 方法支持多种执行模式，通过参数组合实现：

```php
Event::emit(
    event: 'user.login',      // 事件名称
    args: $data,              // 参数（数组或对象）
    async: true,              // 是否异步（默认true）
    delay: 0,                 // 延迟时间（毫秒）
    queue: false              // 是否使用队列（默认false）
);
```

| 模式 | async | delay | queue | 说明 |
|------|-------|-------|-------|------|
| 同步执行 | false | 0 | false | 阻塞执行，返回 EventResponse |
| 异步执行 | true | 0 | false | 不阻塞，监听器并行执行 |
| 队列执行 | - | 0 | true | 不阻塞，监听器串行执行 |
| 延迟执行 | false | >0 | false | 延迟后同步执行 |
| 延迟异步 | true | >0 | false | 延迟后并行执行 |
| 延迟队列 | - | >0 | true | 延迟后队列执行 |

#### 执行模式示例

```php
// 1. 同步执行（阻塞，返回结果）
$response = Event::emit('user.login', $data, async: false);
foreach ($response->results as $result) {
    // 处理每个监听器的结果
}

// 2. 异步执行（不阻塞，监听器并行执行）
Event::emit('user.login', $data, async: true);
// 立即返回，不等待监听器执行完成

// 3. 队列执行（不阻塞，监听器按顺序串行执行）
Event::emit('user.login', $data, queue: true);
// 立即返回，事件进入队列

// 4. 延迟执行（延迟1秒后执行）
$timerId = Event::emit('user.login', $data, delay: 1000, async: false);

// 5. 延迟 + 异步（延迟1秒后并行执行）
Event::emit('user.login', $data, delay: 1000, async: true);

// 6. 延迟 + 队列（延迟1秒后进入队列）
Event::emit('user.login', $data, delay: 1000, queue: true);
```

### 7.4 监听器优先级

监听器按优先级从小到大顺序执行：

```php
#[Event(name: 'user.login', priority: 1)]  // 最先执行
class LogLoginListener
{
    public function run(array $data): void
    {
        Log::info('User login', $data);
    }
}

#[Event(name: 'user.login', priority: 10)]  // 默认优先级
class SendNotificationListener
{
    public function run(array $data): void
    {
        // 发送通知
    }
}

#[Event(name: 'user.login', priority: 100)]  // 最后执行
class UpdateLastLoginTimeListener
{
    public function run(array $data): void
    {
        // 更新最后登录时间
    }
}
```

### 7.5 手动注册监听器

除了使用注解，也可以手动注册监听器：

```php
use Swlib\Event\EventEnum;

// 注册监听器
EventEnum::OnWorkerStartEvent->on(
    listener: [InitializeService::class, 'init'],
    priority: 10
);

// 移除监听器
EventEnum::OnWorkerStartEvent->off(
    [InitializeService::class, 'init']
);
```

### 7.6 事件响应

同步模式下，`emit()` 返回 `EventResponse` 对象：

```php
$response = Event::emit('order.created', $orderData, async: false);

// 获取执行结果
echo "总监听器数: {$response->totalListeners}";
echo "已执行数: {$response->executedListeners}";
echo "是否提前终止: {$response->stoppedEarly}";
echo "总耗时: {$response->executionDuration} 秒";

// 遍历每个监听器的执行结果
foreach ($response->results as $result) {
    echo "监听器: {$result->listenerInfo}";
    echo "优先级: {$result->priority}";
    echo "执行时间: {$result->executionTime}";
    echo "返回值: {$result->result}";
}
```

### 7.7 队列模式

队列模式使用 Swoole Channel 实现事件队列化处理：

```php
// 队列模式执行
Event::emit('heavy.task', $data, queue: true);

// 查看队列长度
use Swlib\Event\Helper\EventQueue;
echo "当前队列长度: " . EventQueue::length();

// 手动关闭队列
EventQueue::close();
```

**队列特性：**
- 空闲 5 秒后自动关闭，无需手动管理
- 保证事件按顺序串行执行
- 不阻塞当前流程
