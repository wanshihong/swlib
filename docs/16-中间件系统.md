## 16. 中间件系统

SWLib 提供了灵活的中间件系统，允许在路由执行前后插入自定义逻辑。中间件可用于认证、授权、日志记录、数据预处理等场景。

### 16.1 概述

#### 中间件执行流程

```
HTTP 请求
    │
    ▼
┌─────────────────────────────────────────────────┐
│              路由解析                            │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│           中间件 1 (Middleware 1)               │
│  handle() → true / ResponseInterface / throw   │
└─────────────────┬───────────────────────────────┘
                  │ 返回 true
                  ▼
┌─────────────────────────────────────────────────┐
│           中间件 2 (Middleware 2)               │
│  handle() → true / ResponseInterface / throw   │
└─────────────────┬───────────────────────────────┘
                  │ 返回 true
                  ▼
┌─────────────────────────────────────────────────┐
│           中间件 N (Middleware N)               │
│  handle() → true / ResponseInterface / throw   │
└─────────────────┬───────────────────────────────┘
                  │ 返回 true
                  ▼
┌─────────────────────────────────────────────────┐
│              控制器方法执行                      │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
            HTTP 响应
```

#### 中间件返回值

| 返回值 | 说明 | 行为 |
|--------|------|------|
| `true` | 继续执行 | 执行下一个中间件或控制器 |
| `ResponseInterface` | 终止请求 | 直接返回响应，不执行后续逻辑 |
| 抛出异常 | 终止请求 | 捕获异常，返回错误响应 |

---

### 16.2 创建中间件

#### 基本结构

所有中间件必须继承 `Swlib\Router\RouterMiddleware` 抽象类：

```php
use Swlib\Router\RouterMiddleware;
use Swlib\Response\ResponseInterface;

class MyMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        // 中间件逻辑

        // 返回 true 继续执行
        return true;

        // 或返回 ResponseInterface 终止请求
        // return JsonResponse::error('错误信息', 401);
    }
}
```

#### 认证中间件示例

```php
use Swlib\Router\RouterMiddleware;
use Swlib\Response\JsonResponse;
use Swlib\Response\ResponseInterface;
use Swlib\Enum\CtxEnum;
use Swlib\Exception\UnauthorizedException;

class AuthMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        // 获取 Authorization 头
        $request = CtxEnum::Request->get();
        $token = $request->header['authorization'] ?? '';

        if (empty($token)) {
            // 方式 1：返回错误响应
            return JsonResponse::error('未授权访问', 401);
        }

        // 验证 token
        $user = $this->validateToken($token);
        if (!$user) {
            // 方式 2：抛出异常
            throw new UnauthorizedException('令牌无效');
        }

        // 存储用户信息到上下文
        CtxEnum::Data->setData('currentUser', $user);

        // 继续执行后续逻辑
        return true;
    }

    private function validateToken(string $token): ?object
    {
        // 验证逻辑...
        return $user ?? null;
    }
}
```

#### 日志中间件示例

```php
use Swlib\Router\RouterMiddleware;
use Swlib\Response\ResponseInterface;
use Swlib\Utils\Log;
use Swlib\Utils\Ip;
use Swlib\Enum\CtxEnum;

class LogMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        $request = CtxEnum::Request->get();
        $uri = CtxEnum::URI->get();
        $ip = Ip::get();

        // 记录请求日志
        Log::info('API 请求', [
            'uri' => $uri,
            'ip' => $ip,
            'method' => $request->server['request_method'],
            'user_agent' => $request->header['user-agent'] ?? '',
        ], 'api_request');

        return true;
    }
}
```

#### 参数验证中间件示例

```php
use Swlib\Router\RouterMiddleware;
use Swlib\Response\JsonResponse;
use Swlib\Response\ResponseInterface;
use Swlib\Enum\CtxEnum;

class ParamsMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        $request = CtxEnum::Request->get();
        $params = $request->get ?? [];

        // 必填参数检查
        $required = ['user_id', 'action'];
        foreach ($required as $field) {
            if (empty($params[$field])) {
                return JsonResponse::error("参数 {$field} 不能为空", 400);
            }
        }

        // 参数类型检查
        if (!is_numeric($params['user_id'])) {
            return JsonResponse::error('user_id 必须是数字', 400);
        }

        // 参数格式化
        $params['user_id'] = (int)$params['user_id'];
        $request->get = $params;

        return true;
    }
}
```

---

### 16.3 应用中间件

#### 控制器级别

在控制器类上应用中间件，该控制器的所有方法都会经过中间件：

```php
use Swlib\Controller\Abstract\AbstractController;
use Swlib\Router\Router;

// 单个中间件
#[Router(middleware: AuthMiddleware::class)]
class UserController extends AbstractController
{
    public function profile(): UserProto
    {
        // 需要认证
    }

    public function settings(): UserProto
    {
        // 需要认证
    }
}

// 多个中间件（按顺序执行）
#[Router(middleware: [LogMiddleware::class, AuthMiddleware::class])]
class OrderController extends AbstractController
{
    // 先执行日志中间件，再执行认证中间件
}
```

#### 方法级别

在单个方法上应用中间件：

```php
use Swlib\Controller\Abstract\AbstractController;
use Swlib\Router\Router;

class UserController extends AbstractController
{
    // 这个方法需要认证
    #[Router(method: 'POST', middleware: AuthMiddleware::class)]
    public function updateProfile(): Success
    {
        // ...
    }

    // 这个方法不需要认证
    #[Router(method: 'POST')]
    public function login(): LoginProto
    {
        // ...
    }

    // 多个中间件
    #[Router(
        method: 'POST',
        middleware: [LogMiddleware::class, AuthMiddleware::class, AdminMiddleware::class]
    )]
    public function deleteUser(): Success
    {
        // 只有管理员可以删除用户
    }
}
```

---

### 16.4 内置中间件

框架提供了两个内置的中间件用于后台管理系统。

#### AdminInitMiddleware

初始化后台管理环境：

```php
use Swlib\Admin\Middleware\AdminInitMiddleware;

#[Router(middleware: AdminInitMiddleware::class)]
class DashboardController extends AbstractController
{
    // 后台控制器
}
```

该中间件会：
- 初始化 `AdminManager` 实例
- 加载后台配置
- 准备模板渲染环境

#### PermissionsMiddleware

检查用户是否有访问后台的权限：

```php
use Swlib\Admin\Middleware\PermissionsMiddleware;
use Swlib\Admin\Middleware\AdminInitMiddleware;

#[Router(middleware: [AdminInitMiddleware::class, PermissionsMiddleware::class])]
class SystemConfigController extends AbstractAdmin
{
    // 需要后台权限
}
```

该中间件会：
- 检查用户是否已登录后台
- 检查用户是否有查看后台的基础权限
- 返回 `true` 或 `JsonResponse` 错误响应

---

### 16.5 中间件执行顺序

中间件按数组顺序依次执行：

```php
#[Router(middleware: [A::class, B::class, C::class])]
public function action()
{
    // 执行顺序：
    // 1. A::handle()
    // 2. B::handle() (如果 A 返回 true)
    // 3. C::handle() (如果 B 返回 true)
    // 4. action() (如果 C 返回 true)
}
```

#### 执行链示例

```php
// 定义中间件
class FirstMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        Log::info('第一个中间件');
        return true;  // 继续执行
    }
}

class SecondMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        Log::info('第二个中间件');
        return JsonResponse::error('被拦截', 403);  // 终止请求
    }
}

class ThirdMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        Log::info('第三个中间件');  // 不会执行
        return true;
    }
}

// 应用中间件
#[Router(middleware: [FirstMiddleware::class, SecondMiddleware::class, ThirdMiddleware::class])]
public function action()
{
    // 不会执行
}

// 日志输出：
// "第一个中间件"
// "第二个中间件"
// 然后返回 403 错误响应
```

---

### 16.6 中间件与上下文

中间件可以通过协程上下文传递数据给控制器：

```php
use Swlib\Router\RouterMiddleware;
use Swlib\Response\ResponseInterface;
use Swlib\Enum\CtxEnum;

class AuthMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        $token = $this->getToken();
        $user = $this->validateToken($token);

        if (!$user) {
            return JsonResponse::error('未授权', 401);
        }

        // 存储用户信息到上下文
        CtxEnum::Data->setData('currentUser', $user);
        CtxEnum::Data->setData('userId', $user->id);

        return true;
    }
}

// 在控制器中获取
class UserController extends AbstractController
{
    #[Router(middleware: AuthMiddleware::class)]
    public function profile(): UserProto
    {
        // 从上下文获取用户信息
        $userId = CtxEnum::Data->getData('userId');
        $user = CtxEnum::Data->getData('currentUser');

        // ...
    }
}
```

---

### 16.7 高级用法

#### 条件中间件

根据条件动态决定是否执行某些逻辑：

```php
class ConditionalMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        $request = CtxEnum::Request->get();
        $uri = CtxEnum::URI->get();

        // 只对特定路由进行检查
        if (str_starts_with($uri, 'admin/')) {
            return $this->checkAdminAuth();
        }

        // 其他路由跳过检查
        return true;
    }

    private function checkAdminAuth(): ResponseInterface|true
    {
        // 管理员认证逻辑
        // ...
    }
}
```

#### 请求计时中间件

```php
class TimingMiddleware extends RouterMiddleware
{
    private float $startTime;

    public function handle(): ResponseInterface|true
    {
        $this->startTime = microtime(true);
        return true;
    }

    public function __destruct()
    {
        $duration = (microtime(true) - $this->startTime) * 1000;
        $uri = CtxEnum::URI->get();

        Log::info('请求耗时', [
            'uri' => $uri,
            'duration' => round($duration, 2) . 'ms'
        ], 'timing');
    }
}
```

#### 限流中间件

```php
use Swlib\Connect\PoolRedis;
use Swlib\Exception\AppException;

class RateLimitMiddleware extends RouterMiddleware
{
    private const int MAX_REQUESTS = 100;
    private const int WINDOW_SECONDS = 60;

    public function handle(): ResponseInterface|true
    {
        $ip = Ip::get();
        $key = "rate_limit:{$ip}";

        $count = PoolRedis::call(function (Redis $redis) use ($key) {
            $count = $redis->incr($key);
            if ($count === 1) {
                $redis->expire($key, self::WINDOW_SECONDS);
            }
            return $count;
        });

        if ($count > self::MAX_REQUESTS) {
            throw new AppException('请求过于频繁，请稍后再试', 429);
        }

        return true;
    }
}
```

---

### 16.8 最佳实践

#### 单一职责

```php
// 推荐：每个中间件只做一件事
class AuthMiddleware extends RouterMiddleware { /* 认证 */ }
class LogMiddleware extends RouterMiddleware { /* 日志 */ }
class RateLimitMiddleware extends RouterMiddleware { /* 限流 */ }

// 不推荐：一个中间件做太多事情
class EverythingMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        $this->checkAuth();
        $this->logRequest();
        $this->rateLimit();
        $this->validateParams();
        // ...
    }
}
```

#### 中间件顺序

```php
// 推荐顺序：日志 -> 限流 -> 认证 -> 权限 -> 业务
#[Router(middleware: [
    LogMiddleware::class,        // 1. 记录请求
    RateLimitMiddleware::class,  // 2. 限流保护
    AuthMiddleware::class,       // 3. 用户认证
    PermissionMiddleware::class, // 4. 权限检查
])]
```

#### 异常处理

```php
// 使用框架异常类
use Swlib\Exception\UnauthorizedException;
use Swlib\Exception\TokenExpiredException;
use Swlib\Exception\RedirectException;

class AuthMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        $token = $this->getToken();

        if (empty($token)) {
            throw new UnauthorizedException();  // 401
        }

        if ($this->isExpired($token)) {
            throw new TokenExpiredException();  // Token 过期
        }

        if (!$this->validate($token)) {
            return JsonResponse::error('无效的 Token', 401);
        }

        return true;
    }
}
```

#### 避免重复检查

```php
class SmartAuthMiddleware extends RouterMiddleware
{
    public function handle(): ResponseInterface|true
    {
        // 检查是否已经认证过
        if (CtxEnum::Data->hasData('currentUser')) {
            return true;  // 已认证，跳过
        }

        // 执行认证逻辑
        // ...
    }
}
```

---

### 16.9 API 参考

#### RouterMiddleware 抽象类

```php
namespace Swlib\Router;

abstract class RouterMiddleware
{
    /**
     * 处理中间件逻辑
     *
     * @return ResponseInterface|true
     *   - true: 继续执行下一个中间件或控制器
     *   - ResponseInterface: 终止请求，返回响应
     * @throws \Throwable 抛出异常终止请求
     */
    abstract public function handle(): ResponseInterface|true;
}
```

#### Router 注解参数

```php
#[Router(
    method: 'POST',                        // HTTP 方法
    url: '/api/user/profile',              // 自定义 URL
    cache: 300,                            // 缓存时间（秒）
    errorTitle: '操作失败',                 // 错误标题
    middleware: [AuthMiddleware::class],   // 中间件数组
    broadcastMessage: null                  // WebSocket 广播
)]
```

| 参数 | 类型 | 说明 |
|------|------|------|
| `method` | string\|array | HTTP 方法，默认 `["GET", "POST"]` |
| `url` | string | 自定义 URL，默认自动生成 |
| `cache` | int | 缓存时间（秒），默认 0 |
| `errorTitle` | string | 错误标题，用于前端 API 生成 |
| `middleware` | string\|array | 中间件类名或数组 |
| `broadcastMessage` | mixed | WebSocket 广播消息 |
