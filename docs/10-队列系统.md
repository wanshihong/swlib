## 10. 队列系统

SWLib 提供了基于注解的延迟消息队列系统，用于处理需要延迟执行或异步执行的任务。

### 10.1 队列注解

使用 `#[QueueAttribute]` 注解将方法标记为队列任务：

```php
use Swlib\Queue\Attribute\QueueAttribute;

class UserOnlineService
{
    // 推荐写法：返回类型为 int，添加占位返回值
    #[QueueAttribute(
        delay: 120,           // 延迟 120 秒执行
        maxRetry: 1,          // 最大重试次数
        clear: true           // 入队时清理之前的同类消息
    )]
    public static function delayedOffline(int $userId, int $appId): int
    {
        // 业务逻辑（消费时执行）
        self::doOffline($userId, $appId);

        return 0; // 占位符，代理调用时返回实际队列ID
    }
}

// 调用示例
$queueId = UserOnlineService::delayedOffline($userId, $appId);
// $queueId 是队列ID，可用于 MessageQueue::cancel($queueId) 取消任务
```

**执行流程：**
1. 调用方法 → 代理拦截 → 投递到队列 → **返回队列ID (int)**
2. 队列消费 → 执行原方法逻辑

### 10.2 注解参数

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `delay` | int | 0 | 延迟执行时间（秒），0 表示立即执行 |
| `maxRetry` | int | 30 | 最大重试次数 |
| `retryIntervals` | array | `[5, 10, 20, 30, ...]` | 重试时间间隔数组（秒） |
| `clear` | bool | false | 入队时是否清理之前的同类消息 |
| `priority` | int | 0 | 执行优先级（多个注解时需显式指定） |
| `async` | bool | false | 是否异步执行 |

### 10.3 返回值说明

**重要：** 使用 `#[QueueAttribute]` 注解的方法，调用时不会立即执行方法体，而是返回**队列ID**：

```php
// 调用方
$queueId = UserService::sendEmail($userId);  // 返回 int (队列ID)

// 可以用队列ID取消任务
MessageQueue::cancel($queueId);

// 查询任务状态
$status = MessageQueue::getStatus($queueId);
```

**建议：** 将方法返回类型声明为 `int`，并添加 `return 0;` 占位符，以便 IDE 正确推断返回类型。

### 10.4 使用示例

#### 基本队列任务

```php
use Swlib\Queue\Attribute\QueueAttribute;

class EmailService
{
    #[QueueAttribute(delay: 0)]
    public static function sendWelcome(int $userId): int
    {
        $user = new UserTable()->where([UserTable::ID => $userId])->selectOne();

        // 发送欢迎邮件
        Mail::to($user->email)->send('欢迎注册！');

        return 0;
    }
}

// 调用
EmailService::sendWelcome($userId);
```

#### 延迟执行任务

```php
#[QueueAttribute(delay: 600)]  // 10分钟后执行
public static function expireOrder(int $orderId): int
{
    new OrderTable()->where([OrderTable::ID => $orderId])->update([
        OrderTable::STATUS => 'expired'
    ]);

    return 0;
}
```

#### 任务清理和重试

```php
#[QueueAttribute(
    delay: 60,               // 60秒后执行
    maxRetry: 3,             // 最多重试3次
    retryIntervals: [60, 300, 900],  // 重试间隔：1分钟、5分钟、15分钟
    clear: true              // 清理之前的同类任务
)]
public static function syncUserData(int $userId): int
{
    // 同步用户数据到第三方系统
    // 如果失败，会按 retryIntervals 的时间间隔重试

    return 0;
}
```

#### 进度更新

在队列任务中更新执行进度：

```php
use Swlib\Queue\MessageQueue;

#[QueueAttribute(delay: 0)]
public static function processBatch(int $batchId): int
{
    $items = new BatchItemTable()
        ->where([BatchItemTable::BATCH_ID => $batchId])
        ->selectAll();

    $total = $items->count();

    foreach ($items as $index => $item) {
        // 处理单个项目
        $this->processItem($item);

        // 更新进度 (0.0 - 1.0)
        $progress = ($index + 1) / $total;
        MessageQueue::updateProgress($msgId, $progress);
    }

    return 0;
}
```

**注意：** 要在任务中使用 `updateProgress`，需要在方法签名中接收 `$msgId` 参数（执行时自动传入）：

```php
use Generate\TablesDto\Main\MessageQueueTableDto;

#[QueueAttribute(delay: 0)]
public static function processBatch(int $batchId, MessageQueueTableDto $dto): int
{
    $msgId = $dto->id;  // 获取队列消息ID
    // ...
    MessageQueue::updateProgress($msgId, $progress);
    return 0;
}
```

### 10.5 查询和取消

#### 查询任务状态

```php
use Swlib\Queue\MessageQueue;

$status = MessageQueue::getStatus($msgId);

// 返回：
// [
//     'progress' => 0.5,      // 进度 0-1
//     'error' => null,       // 错误信息
//     'isSuccess' => false,  // 是否成功
//     'isDiscard' => false    // 是否已丢弃
// ]
```

#### 取消任务

```php
use Swlib\Queue\MessageQueue;

// 只能取消未执行且未成功的任务
$cancelled = MessageQueue::cancel($msgId);
```

### 10.6 事务支持

队列任务支持在事务中执行。如果方法上有 `#[Transaction]` 注解，任务会自动在事务中执行：

```php
use Swlib\Queue\Attribute\QueueAttribute;
use Swlib\Table\Attributes\Transaction;

class OrderService
{
    #[QueueAttribute(delay: 0)]
    #[Transaction]
    public static function processOrder(int $orderId): int
    {
        // 这些操作会在事务中执行
        new OrderTable()->where([OrderTable::ID => $orderId])->update([...]);
        new OrderLogTable()->insert([...]);

        return 0;
    }
}
```

### 10.7 队列消费

队列由 `MessageQueueProcess` 进程自动消费，每 10 秒执行一次：

```php
use Swlib\Process\Attribute\ProcessAttribute;

#[ProcessAttribute(interval: 10 * 1000)]  // 每10秒执行一次
class MessageQueueProcess extends AbstractProcess
{
    public function handle(Server $server, Process $process): void
    {
        MessageQueue::run();  // 执行队列任务
    }
}
```

**消费逻辑：**
1. 查询到期的待执行消息（最多96条）
2. 使用 Redis 分布式锁确保每个消息同时只被一个消费者执行
3. 执行成功后标记为完成
4. 执行失败后根据重试策略安排下次执行时间
5. 清理7天前的已完成消息

### 10.8 最佳实践

1. **返回类型声明**：始终声明返回类型为 `int` 并添加 `return 0;`
2. **静态方法**：队列任务推荐使用静态方法
3. **幂等性**：确保任务可以安全地重复执行
4. **错误处理**：捕获并处理可能出现的异常
5. **进度更新**：对于长时间任务，使用 `updateProgress` 更新进度

```php
use Swlib\Queue\Attribute\QueueAttribute;
use Swlib\Exception\AppException;

#[QueueAttribute(
    delay: 300,
    maxRetry: 3,
    clear: true
)]
public static function syncUserData(int $userId): int
{
    try {
        // 1. 检查用户是否存在
        $user = new UserTable()->where([UserTable::ID => $userId])->selectOne();
        if (!$user) {
            return 0;  // 用户不存在，直接返回
        }

        // 2. 执行同步逻辑
        $this->doSync($user);

        return 0;
    } catch (AppException $e) {
        // 业务异常，不重试
        Log::error("同步用户数据失败: {$e->getMessage()}");
        throw $e;
    }
}
```
