## 8. 进程管理

SWLib 支持自定义用户进程，适合后台数据处理、定时同步、消息推送等场景。自定义进程独立于 Worker 进程运行，不会阻塞请求处理。

### 8.1 概述

#### 进程架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      Swoole Server                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Master Process                         │   │
│  └──────────────────────────────────────────────────────────┘   │
│                           │                                     │
│         ┌─────────────────┼─────────────────┐                  │
│         ▼                 ▼                 ▼                  │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐          │
│  │  Worker 0   │   │  Worker 1   │   │  Worker N   │   ...    │
│  │  处理请求   │   │  处理请求   │   │  处理请求   │           │
│  └─────────────┘   └─────────────┘   └─────────────┘          │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   User Processes                          │   │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐            │   │
│  │  │ Process 1 │  │ Process 2 │  │ Process N │    ...      │   │
│  │  │ 数据同步  │  │ 消息推送  │  │ 统计计算  │            │   │
│  │  └───────────┘  └───────────┘  └───────────┘            │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   Task Workers                            │   │
│  │  ┌───────────┐  ┌───────────┐                            │   │
│  │  │ Task 0    │  │ Task 1    │    ...                     │   │
│  │  │ 异步任务  │  │ 异步任务  │                            │   │
│  │  └───────────┘  └───────────┘                            │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 进程类型

| 进程类型 | 说明 | 数量 |
|---------|------|------|
| Master Process | 主进程，管理子进程 | 1 |
| Worker Process | 处理 HTTP 请求 | 配置决定 |
| User Process | 自定义进程，执行后台任务 | 按需定义 |
| Task Worker | 异步任务处理 | 配置决定 |

---

### 8.2 创建自定义进程

#### 使用注解定义

```php
use Swlib\Process\Attribute\ProcessAttribute;

#[ProcessAttribute(
    interval: 60000,               // 执行间隔（毫秒）
    redirect_stdin_stdout: false,  // 是否重定向标准输入输出
    pipe_type: 0,                  // 管道类型
    enable_coroutine: true         // 是否启用协程
)]
class DataSyncProcess
{
    public function run($server, $process): void
    {
        echo "开始数据同步..." . PHP_EOL;

        try {
            $this->syncData();
            echo "数据同步完成" . PHP_EOL;
        } catch (Throwable $e) {
            echo "数据同步失败: " . $e->getMessage() . PHP_EOL;
        }
    }

    private function syncData(): void
    {
        // 数据同步逻辑
        // ...
    }
}
```

#### 使用抽象基类

```php
use Swlib\Process\Abstract\AbstractProcess;
use Swlib\Process\Attribute\ProcessAttribute;
use Swoole\Http\Server as HttpServer;
use Swoole\Process;
use Swoole\WebSocket\Server as WSServer;

#[ProcessAttribute(interval: 30000)]
class MessagePushProcess extends AbstractProcess
{
    public function handle(WSServer|HttpServer $server, Process $process): void
    {
        // 获取待推送的消息
        $messages = $this->getPendingMessages();

        foreach ($messages as $message) {
            // 推送给在线用户
            $this->pushToUsers($server, $message);
        }
    }

    private function getPendingMessages(): array
    {
        // 获取待推送消息
        return [];
    }

    private function pushToUsers($server, array $message): void
    {
        // 推送逻辑
    }
}
```

---

### 8.3 进程配置参数

#### ProcessAttribute 注解参数

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `interval` | int | 200 | 执行间隔（毫秒），任务执行完成后等待多久再次执行 |
| `redirect_stdin_stdout` | bool | false | 是否重定向标准输入输出到管道 |
| `pipe_type` | int | 0 | 管道类型：0=无管道，1=SOCK_STREAM，2=SOCK_DGRAM |
| `enable_coroutine` | bool | true | 是否启用协程支持 |

#### interval 参数详解

`interval` 不是定时执行，而是**本次执行完成后等待的时间**：

```php
// 假设 interval = 60000 (60秒)
// 实际执行间隔 = 任务执行时间 + 60秒

#[ProcessAttribute(interval: 60000)]
class DataSyncProcess
{
    public function run($server, $process): void
    {
        $start = time();

        // 假设这个任务需要 10 秒
        $this->syncData();  // 10秒

        $end = time();
        echo "任务耗时: " . ($end - $start) . "秒" . PHP_EOL;

        // 等待 60 秒后再次执行
        // 下次执行在 10 + 60 = 70 秒后
    }
}
```

#### 管道类型说明

| pipe_type | 说明 | 使用场景 |
|-----------|------|---------|
| 0 | 无管道 | 不需要进程间通信 |
| 1 | SOCK_STREAM | 需要流式通信（TCP 风格） |
| 2 | SOCK_DGRAM | 需要数据报通信（UDP 风格） |

---

### 8.4 进程间通信

#### 使用管道通信

```php
use Swlib\Process\Attribute\ProcessAttribute;

#[ProcessAttribute(
    interval: 1000,
    pipe_type: 1,  // 启用管道
    enable_coroutine: true
)]
class WorkerProcess
{
    public function run($server, $process): void
    {
        // 向主进程发送数据
        $process->write(json_encode([
            'type' => 'status',
            'message' => '处理完成',
            'time' => time()
        ]));

        // 从管道读取数据（阻塞）
        // $data = $process->read();
    }
}

// 在服务器事件中接收
class OnPipeMessageEvent
{
    public function handle($server, $srcWorkerId, $data): void
    {
        $message = json_decode($data, true);
        // 处理来自自定义进程的消息
    }
}
```

#### 使用共享内存 (Table)

```php
use Swoole\Table;

// 创建共享内存表
$table = new Table(1024);
$table->column('value', Table::TYPE_STRING, 256);
$table->create();

// 在进程中读写
#[ProcessAttribute(interval: 1000)]
class SharedMemoryProcess
{
    private Table $table;

    public function __construct()
    {
        global $table;  // 全局共享
        $this->table = $table;
    }

    public function run($server, $process): void
    {
        // 读取
        $value = $this->table->get('key', 'value');

        // 写入
        $this->table->set('key', ['value' => 'new_value']);
    }
}
```

---

### 8.5 实际应用示例

#### 数据同步进程

```php
use Swlib\Process\Attribute\ProcessAttribute;
use Generate\Tables\UserTable;
use Swlib\Connect\PoolRedis;
use Swlib\Utils\Log;

#[ProcessAttribute(interval: 60000)]  // 每分钟同步一次
class UserSyncProcess
{
    public function run($server, $process): void
    {
        Log::info('开始用户数据同步');

        try {
            // 1. 获取需要同步的用户
            $users = new UserTable()
                ->where([UserTable::SYNC_STATUS => 0])
                ->page(1, 100)
                ->selectAll();

            foreach ($users as $user) {
                // 2. 同步到外部系统
                $this->syncToExternal($user);

                // 3. 更新同步状态
                new UserTable()
                    ->where([UserTable::ID => $user->id])
                    ->update([UserTable::SYNC_STATUS => 1]);
            }

            Log::info('用户数据同步完成', ['count' => count($users)]);

        } catch (Throwable $e) {
            Log::saveException($e, 'user_sync');
        }
    }

    private function syncToExternal($user): void
    {
        // 同步逻辑
    }
}
```

#### 消息队列消费进程

```php
use Swlib\Process\Attribute\ProcessAttribute;
use Swlib\Connect\PoolRedis;
use Swlib\Utils\Log;

#[ProcessAttribute(interval: 100)]  // 每 100ms 检查一次
class QueueConsumerProcess
{
    public function run($server, $process): void
    {
        PoolRedis::call(function (Redis $redis) {
            // 阻塞获取队列消息
            $result = $redis->brPop('message_queue', 5);

            if ($result) {
                [, $message] = $result;
                $this->processMessage($message);
            }
        });
    }

    private function processMessage(string $message): void
    {
        $data = json_decode($message, true);

        try {
            // 处理消息
            match ($data['type']) {
                'email' => $this->sendEmail($data),
                'sms' => $this->sendSms($data),
                'push' => $this->sendPush($data),
                default => Log::warning('未知消息类型', $data)
            };
        } catch (Throwable $e) {
            Log::saveException($e, 'queue_consumer');
        }
    }

    private function sendEmail(array $data): void { /* ... */ }
    private function sendSms(array $data): void { /* ... */ }
    private function sendPush(array $data): void { /* ... */ }
}
```

#### WebSocket 推送进程

```php
use Swlib\Process\Attribute\ProcessAttribute;
use Swlib\DataManager\FdManager;
use Swlib\Utils\Log;

#[ProcessAttribute(interval: 1000)]
class WebSocketPushProcess
{
    public function run($server, $process): void
    {
        // 获取需要推送的消息
        $messages = $this->getPendingMessages();

        foreach ($messages as $message) {
            // 推送给指定用户
            if ($message['user_id']) {
                $fd = FdManager::getFdByUserId($message['user_id']);
                if ($fd && $server->isEstablished($fd)) {
                    $server->push($fd, json_encode($message['data']));
                }
            }

            // 推送给所有用户
            if ($message['broadcast']) {
                foreach ($server->connections as $fd) {
                    if ($server->isEstablished($fd)) {
                        $server->push($fd, json_encode($message['data']));
                    }
                }
            }
        }
    }

    private function getPendingMessages(): array
    {
        // 从数据库或缓存获取待推送消息
        return [];
    }
}
```

---

### 8.6 进程生命周期

#### 启动流程

```
1. 框架解析 ProcessAttribute 注解
2. 生成 ProcessMap 映射文件
3. 服务器启动时调用 Process::run()
4. 为每个进程配置创建 Swoole\Process
5. 设置进程名称为 php_user_proc:ClassName
6. 进入执行循环
```

#### 执行循环

```php
// 框架内部实现
while (true) {
    $ctrl->$methodName($server, $process);  // 执行任务

    if ($interval > 0) {
        System::sleep($interval / 1000);    // 等待间隔时间
    }
}
```

#### 进程退出

```php
// 优雅退出
#[ProcessAttribute(interval: 5000)]
class GracefulProcess
{
    private bool $running = true;

    public function run($server, $process): void
    {
        // 监听信号
        Swoole\Process::signal(SIGTERM, function () {
            $this->running = false;
        });

        while ($this->running) {
            $this->doWork();
            System::sleep(1);
        }

        echo "进程优雅退出" . PHP_EOL;
    }
}
```

---

### 8.7 最佳实践

#### 避免阻塞操作

```php
// 不推荐：长时间阻塞
#[ProcessAttribute(interval: 60000)]
class BadProcess
{
    public function run($server, $process): void
    {
        sleep(300);  // 阻塞 5 分钟
    }
}

// 推荐：使用协程
#[ProcessAttribute(interval: 60000, enable_coroutine: true)]
class GoodProcess
{
    public function run($server, $process): void
    {
        System::sleep(300);  // 协程 sleep，不阻塞其他协程
    }
}
```

#### 异常处理

```php
#[ProcessAttribute(interval: 10000)]
class SafeProcess
{
    public function run($server, $process): void
    {
        try {
            $this->doWork();
        } catch (Throwable $e) {
            Log::saveException($e, 'process');
            // 不抛出异常，让进程继续运行
        }
    }
}
```

#### 合理设置间隔

```php
// 高频任务：100ms - 1s
#[ProcessAttribute(interval: 100)]
class HighFrequencyProcess { }

// 中频任务：1s - 10s
#[ProcessAttribute(interval: 5000)]
class MediumFrequencyProcess { }

// 低频任务：10s - 5min
#[ProcessAttribute(interval: 60000)]
class LowFrequencyProcess { }
```

---

### 8.8 调试与监控

#### 查看进程状态

```bash
# 查看所有 PHP 进程
ps aux | grep php

# 输出示例：
# php_user_proc:DataSyncProcess
# php_user_proc:MessagePushProcess
# php_swoole_worker
```

#### 日志记录

```php
#[ProcessAttribute(interval: 1000)]
class MonitoredProcess
{
    public function run($server, $process): void
    {
        $start = microtime(true);

        Log::info('进程开始执行', ['process' => __CLASS__]);

        try {
            $this->doWork();
            $duration = round((microtime(true) - $start) * 1000, 2);
            Log::info('进程执行完成', ['duration' => $duration . 'ms']);
        } catch (Throwable $e) {
            Log::error('进程执行失败', [
                'error' => $e->getMessage(),
                'duration' => round((microtime(true) - $start) * 1000, 2) . 'ms'
            ]);
        }
    }
}
```

---

### 8.9 API 参考

#### ProcessAttribute 注解

```php
namespace Swlib\Process\Attribute;

#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
class ProcessAttribute
{
    public function __construct(
        public bool $redirect_stdin_stdout = false,
        public int  $pipe_type = 0,
        public bool $enable_coroutine = true,
        public int  $interval = 200  // 毫秒
    ) {}
}
```

#### AbstractProcess 抽象类

```php
namespace Swlib\Process\Abstract;

abstract class AbstractProcess
{
    abstract public function handle(
        Swoole\WebSocket\Server|Swoole\Http\Server $server,
        Swoole\Process $process
    ): void;
}
```

#### Process 类方法

| 方法 | 说明 |
|------|------|
| `run($server)` | 静态方法，启动所有自定义进程 |
