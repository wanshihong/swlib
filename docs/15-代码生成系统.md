## 15. 代码生成系统

SWLib 框架的核心特性之一是自动代码生成系统。框架在启动时会扫描数据库表结构，自动生成 Table 映射类、DTO 对象、Model 模型、CRUD 控制器、后台管理界面和 Protobuf 协议文件。

### 15.1 概述

#### 代码生成流程

```
┌─────────────────┐
│   数据库表结构   │
│  (MySQL/MariaDB)│
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   ParseTable    │  ◀── 解析器入口
│   解析器        │
└────────┬────────┘
         │
    ┌────┴────┬─────────┬─────────┬─────────┬─────────┐
    ▼         ▼         ▼         ▼         ▼         ▼
┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐
│ Table │ │TableDto│ │ Model │ │ CRUD  │ │ Admin │ │ Proto │
└───────┘ └───────┘ └───────┘ └───────┘ └───────┘ └───────┘
    │         │         │         │         │         │
    ▼         ▼         ▼         ▼         ▼         ▼
runtime/  runtime/  runtime/  runtime/  runtime/  protos/
Generate/ Generate/ Generate/ codes/    codes/    Database/
Tables/   TablesDto/ Models/   crud/     admin/
```

#### 生成时机

代码生成在以下情况下自动触发：

1. **首次启动** - 应用首次运行时
2. **表结构变更** - 数据库表结构修改后重启服务
3. **手动触发** - 删除 `runtime/` 目录后重启

#### 生成器目录结构

```
Swlib/Parse/
├── Table/                      # 表相关代码生成
│   ├── ParseTable.php          # 解析器入口
│   ├── ParseTableTable.php     # Table 类生成器
│   ├── ParseTableTableDto.php  # DTO 类生成器
│   ├── ParseTableModel.php     # Model 类生成器
│   ├── ParseTableCRUD.php      # CRUD 控制器生成器
│   ├── ParseTableAdmin.php     # 后台管理生成器
│   ├── ParseTableProtoc.php    # Protobuf 生成器
│   └── ParseTableMap.php       # 表映射生成器
├── Router/                     # 路由相关生成
│   └── GenApi/                 # 前端 API 代码生成
├── Helper/                     # 辅助工具
│   ├── FieldConflictDetector.php    # 字段冲突检测
│   └── FieldDefaultValueHelper.php  # 默认值处理
└── Config/                     # 配置验证
```

---

### 15.2 生成内容详解

#### Table 类 (runtime/Generate/Tables/)

Table 类是数据表的映射类，提供字段常量和查询构建能力。

```php
// 自动生成的 Table 类示例
namespace Generate\Tables\Wenyuehui;

use Generate\TablesDto\Wenyuehui\UserTableDto;

class UserTable implements TableInterface
{
    use FuncTrait;
    use RawQueryTrait;
    use SqlTrait;
    use TableEventTrait;

    // 数据库和表信息
    const string DATABASES = "wenyuehui";
    const string TABLE_NAME = "user";
    const string DTO_CLASS = UserTableDto::class;

    // 主键
    const string PRI_KEY = "t0f0";

    // 字段常量
    const string ID = "t0f0";
    const string USERNAME = "t0f1";
    const string EMAIL = "t0f2";
    const string STATUS = "t0f3";
    const string CREATED_AT = "t0f4";

    // 所有字段
    const array ALL_FIELD = [
        self::ID,
        self::USERNAME,
        self::EMAIL,
        self::STATUS,
        self::CREATED_AT,
    ];

    // ORM 生命周期事件
    const string SelectBefore = "table.wenyuehui.user.select.before";
    const string SelectAfter  = "table.wenyuehui.user.select.after";
    const string InsertBefore = "table.wenyuehui.user.insert.before";
    const string InsertAfter  = "table.wenyuehui.user.insert.after";
    const string UpdateBefore = "table.wenyuehui.user.update.before";
    const string UpdateAfter  = "table.wenyuehui.user.update.after";
    const string DeleteBefore = "table.wenyuehui.user.delete.before";
    const string DeleteAfter  = "table.wenyuehui.user.delete.after";
}
```

#### TableDto 类 (runtime/Generate/TablesDto/)

DTO 类是数据传输对象，提供类型安全的属性访问。

```php
// 自动生成的 DTO 类示例
namespace Generate\TablesDto\Wenyuehui;

class UserTableDto
{
    public int $id;
    public string $username;
    public string $email;
    public int $status;
    public int $createdAt;

    // 列表数据
    public ?array $__rows = null;
    public int $__total = 0;

    // 保存方法
    public function __save(): int { ... }

    // 数组转换
    public function __toArray(): array { ... }
}
```

#### Model 类 (runtime/Generate/Models/)

Model 类是业务模型，封装了数据转换和业务逻辑。

```php
// 自动生成的 Model 类示例
namespace Generate\Models\Wenyuehui;

use Generate\TablesDto\Wenyuehui\UserTableDto;
use Protobuf\Wenyuehui\User\UserProto;

class UserModel
{
    // 枚举映射
    private static array $statusMap = [
        1 => '正常',
        0 => '禁用',
    ];

    // 从 Protobuf 请求创建 DTO
    public static function request(UserProto $request): UserTableDto { ... }

    // 格式化单条数据
    public static function formatItem(UserTableDto $dto): array { ... }

    // 格式化列表数据
    public static function formatList(array $list): array { ... }
}
```

#### CRUD 控制器 (runtime/codes/crud/)

CRUD 控制器提供基础的数据操作接口。

```php
// 自动生成的 CRUD 控制器示例
namespace App\Controller\User;

use Swlib\Controller\Abstract\AbstractController;
use Swlib\Router\Router;

#[Router(method: 'POST')]
class Save extends AbstractController
{
    #[Router(errorTitle: '保存用户失败')]
    public function run(UserProto $request): Success
    {
        $dto = UserModel::request($request);
        // ... 保存逻辑
    }
}

#[Router(method: 'POST')]
class Lists extends AbstractController
{
    #[Router(errorTitle: '获取用户列表失败')]
    public function run(UserProto $request): UserListsProto
    {
        // ... 列表查询逻辑
    }
}

#[Router(method: 'POST')]
class Detail extends AbstractController
{
    #[Router(errorTitle: '获取用户详情失败')]
    public function run(UserProto $request): UserProto
    {
        // ... 详情查询逻辑
    }
}

#[Router(method: 'POST')]
class Remove extends AbstractController
{
    #[Router(errorTitle: '删除用户失败')]
    public function run(UserProto $request): Success
    {
        // ... 删除逻辑
    }
}
```

#### 后台管理 (runtime/codes/admin/)

后台管理控制器生成完整的 CRUD 管理界面。

---

### 15.3 字段冲突检测

框架在解析过程中会自动检测字段名冲突，避免生成有问题的代码。

#### 冲突类型

| 冲突类型 | 说明 | 示例 |
|---------|------|------|
| Table 类冲突 | 字段名与 PHP 保留字冲突 | `class`, `function`, `namespace` |
| DTO 类冲突 | 字段名转换后重复 | `user_name` 和 `userName` 转换后相同 |

#### 检测机制

```php
// 框架会自动检测以下冲突：
$conflicts = FieldConflictDetector::detect($fields);

if (!empty($conflicts['table'])) {
    // Table 类冲突
}

if (!empty($conflicts['dto'])) {
    // DTO 类冲突
}
```

#### 冲突报告示例

```
========================================
严重错误：检测到字段名冲突！
========================================

数据库: wenyuehui
表名: user

【Table 类冲突】
  字段: class
    - 与 PHP 保留字冲突

【DTO 类冲突】
  字段: user_name
    - 与 userName 冲突

========================================
请修改数据库字段名后重新运行解析！
========================================
```

#### 保留字段处理

框架会自动重命名某些保留字段：

```php
// 保留字段会被自动添加前缀
'class'       → 'field_class'
'DATABASES'   → 'field_DATABASES'
'TABLE_NAME'  → 'field_TABLE_NAME'
'PRI_KEY'     → 'field_PRI_KEY'
```

---

### 15.4 生成的目录结构

```
project/
├── runtime/
│   ├── Generate/
│   │   ├── Tables/                    # Table 类
│   │   │   └── Wenyuehui/
│   │   │       ├── UserTable.php
│   │   │       ├── OrderTable.php
│   │   │       └── ...
│   │   ├── TablesDto/                 # DTO 类
│   │   │   └── Wenyuehui/
│   │   │       ├── UserTableDto.php
│   │   │       └── ...
│   │   └── Models/                    # Model 类
│   │       └── Wenyuehui/
│   │           ├── UserModel.php
│   │           └── ...
│   └── codes/
│       ├── crud/                      # CRUD 控制器
│       │   └── wenyuehui/
│       │       └── User/
│       │           ├── Save.php
│       │           ├── Lists.php
│       │           ├── Detail.php
│       │           └── Remove.php
│       └── admin/                     # 后台管理
│           └── wenyuehui/
│               └── User/
│                   └── UserAdmin.php
├── protos/                            # Protobuf 文件
│   └── Wenyuehui/
│       ├── User.proto
│       ├── Order.proto
│       └── field_maps/               # 字段映射缓存
│           └── Wenyuehui/
│               └── User.json
└── ...
```

---

### 15.5 配置数据库连接

数据库连接配置决定了代码生成的来源和命名空间。

```php
// .env 配置
DB_HOST=127.0.0.1
DB_PORT=3306
DB_NAME=mydb
DB_USER=root
DB_PASS=password
DB_CHARSET=utf8mb4

// 多数据库配置（在项目中配置）
'databases' => [
    'default' => [
        'host' => '127.0.0.1',
        'port' => 3306,
        'database' => 'mydb',
        'user' => 'root',
        'pass' => 'password',
        'charset' => 'utf8mb4',
        'namespace' => 'Wenyuehui',  // 命名空间
    ],
    'slave' => [
        'host' => '127.0.0.1',
        'database' => 'slave_db',
        'namespace' => 'Slave',
    ],
],
```

#### 命名空间映射

| 数据库名 | 命名空间 | 生成的类 |
|---------|---------|---------|
| `wenyuehui` | `Wenyuehui` | `Generate\Tables\Wenyuehui\UserTable` |
| `product_db` | `ProductDb` | `Generate\Tables\ProductDb\ProductTable` |

---

### 15.6 字段元数据注解

生成的 Table 类包含字段元数据注解，用于后台管理等场景。

```php
use Swlib\Table\Attributes\FieldMetadata;

class UserTable
{
    #[FieldMetadata(
        name: 'username',
        type: 'varchar',
        comment: '用户名',
        length: 50,
        nullable: false
    )]
    const string USERNAME = "t0f1";
}
```

#### 元数据属性

| 属性 | 说明 | 示例 |
|------|------|------|
| `name` | 字段名 | `username` |
| `type` | 数据类型 | `varchar`, `int`, `text` |
| `comment` | 字段注释 | `用户名` |
| `length` | 字段长度 | `50` |
| `nullable` | 是否可空 | `true`, `false` |
| `default` | 默认值 | `0`, `''` |
| `enum` | 枚举值 | `['active', 'inactive']` |

---

### 15.7 ORM 生命周期事件

每个生成的 Table 类都包含 ORM 生命周期事件常量。

#### 可用事件

| 事件 | 触发时机 |
|------|---------|
| `SelectBefore` | 查询前 |
| `SelectAfter` | 查询后 |
| `InsertBefore` | 插入前 |
| `InsertAfter` | 插入后 |
| `UpdateBefore` | 更新前 |
| `UpdateAfter` | 更新后 |
| `DeleteBefore` | 删除前 |
| `DeleteAfter` | 删除后 |

#### 使用事件

```php
use Generate\Tables\UserTable;
use Swlib\Event\EventEnum;

// 监听用户表的查询后事件
EventEnum::addListener(UserTable::SelectAfter, function ($data) {
    $result = $data['result'];
    Log::info('用户查询完成', ['count' => count($result)]);
});

// 监听用户表的插入前事件
EventEnum::addListener(UserTable::InsertBefore, function ($data) {
    $dto = $data['dto'];
    // 可以修改 DTO 数据
    $dto->createdAt = time();
});
```

---

### 15.8 API 代码生成

框架支持生成前端 API 调用代码。

#### 支持的前端类型

| 类型 | 目录 | 说明 |
|------|------|------|
| TypeScript | `Swlib/Parse/Router/GenApi/` | 用于 Web 前端 |
| Flutter/Dart | `Swlib/Parse/Router/GenApi/` | 用于移动端 |

#### 生成配置

```php
// API 生成配置
'api_gen' => [
    'enabled' => true,
    'output_dir' => ROOT_DIR . 'frontend/src/api/',
    'types' => ['typescript', 'dart'],
],
```

---

### 15.9 重新生成代码

#### 方法一：删除 runtime 目录

```bash
rm -rf runtime/
# 重启服务，代码会自动重新生成
```

#### 方法二：删除锁文件

```bash
rm runtime/lock/create_tables.lock
# 重启服务
```

#### 方法三：仅重新生成特定模块

```bash
# 只删除 Table 类
rm -rf runtime/Generate/Tables/

# 只删除 Protobuf 文件
rm -rf protos/Wenyuehui/
```

---

### 15.10 最佳实践

#### 命名规范

```sql
-- 推荐：清晰的字段名
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) COMMENT '用户名',
    email VARCHAR(100) COMMENT '邮箱',
    created_at INT COMMENT '创建时间'
);

-- 不推荐：可能导致冲突的命名
CREATE TABLE bad_names (
    class VARCHAR(50),      -- PHP 保留字
    user_name VARCHAR(50),  -- 与 userName 混淆
    userName VARCHAR(50)    -- 与 user_name 混淆
);
```

#### 字段注释

```sql
-- 好的注释会生成更好的文档
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    status TINYINT COMMENT '订单状态：0待支付 1已支付 2已发货 3已完成 4已取消',
    -- Protobuf 扩展字段
    id INT COMMENT 'protobuf:ext:json:["item:isPaid:bool", "item:payTime:int64"]'
);
```

#### 生成后不要手动修改

```
⚠️ 重要：runtime/ 目录下的文件由框架自动生成
手动修改的内容会在下次代码生成时被覆盖
```

#### 版本控制

```gitignore
# .gitignore 建议配置
/runtime/
/protos/
```

---

### 15.11 故障排查

#### 代码未生成

**可能原因**：
1. 数据库连接失败
2. 数据库中没有表
3. 权限问题

**解决方法**：
```bash
# 检查数据库连接
php -r "new mysqli('127.0.0.1', 'root', 'password', 'mydb');"

# 检查目录权限
chmod -R 777 runtime/
```

#### 字段冲突

**症状**：解析器停止并输出冲突信息

**解决方法**：根据提示修改数据库字段名

#### Proto 编译失败

**症状**：`protoc: command not found`

**解决方法**：
```bash
# 安装 protoc
brew install protobuf  # macOS
apt-get install protobuf-compiler  # Ubuntu
```
