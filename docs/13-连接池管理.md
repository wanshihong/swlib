## 13. 连接池管理

SWLib 基于 Swoole 的连接池技术，为 MySQL 和 Redis 提供高性能的连接复用机制。连接池可以显著减少连接创建开销，提高数据库访问性能。

### 13.1 概述

#### 为什么需要连接池

传统的数据库访问模式：
- 每次请求创建新连接
- 连接建立需要 TCP 握手、认证等开销
- 高并发时连接数急剧增加

使用连接池的优势：
- **连接复用**：避免频繁创建/销毁连接
- **连接限制**：控制最大连接数，保护数据库
- **快速响应**：直接从池中获取可用连接
- **健康检测**：自动检测并剔除无效连接

#### 架构图

```
┌──────────────────────────────────────────────────────────────┐
│                        应用请求                               │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│                     连接池管理器                              │
│  ┌─────────────────────┐    ┌─────────────────────┐          │
│  │   MySQL 连接池       │    │   Redis 连接池       │          │
│  │  PoolMySQL          │    │  PoolRedis          │          │
│  │                     │    │                     │          │
│  │  ┌───┐ ┌───┐ ┌───┐  │    │  ┌───┐ ┌───┐ ┌───┐  │          │
│  │  │ C │ │ C │ │ C │  │    │  │ C │ │ C │ │ C │  │          │
│  │  └───┘ └───┘ └───┘  │    │  └───┘ └───┘ └───┘  │          │
│  │   连接1  连接2  连接N │    │   连接1  连接2  连接N │          │
│  └─────────────────────┘    └─────────────────────┘          │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
        ┌─────────────────────────────────────────┐
        │            心跳检测 (定时)               │
        │   SELECT 1 (MySQL)  /  PING (Redis)     │
        └─────────────────────────────────────────┘
```

---

### 13.2 配置项

#### MySQL 连接池配置

在 `.env` 文件中配置：

```env
# 连接池大小
DB_POOL_NUM=10        # 每个数据库的连接池大小

# 心跳间隔（秒）
DB_HEART=10           # 每 10 秒进行一次心跳检测

# 数据库连接配置
DB_HOST=127.0.0.1
DB_PORT=3306
DB_NAME=mydb
DB_USER=root
DB_PASS=password
DB_CHARSET=utf8mb4
```

#### Redis 连接池配置

```env
# Redis 连接池大小
REDIS_POOL_NUM=10

# Redis 连接配置
REDIS_HOST=127.0.0.1
REDIS_PORT=6379
REDIS_AUTH=           # Redis 密码（可选）

# 是否禁用 Redis 缓存
DISABLED_REDIS_CACHE=false
```

---

### 13.3 Redis 连接池

#### 基本使用

使用 `PoolRedis::call()` 方法执行 Redis 操作：

```php
use Swlib\Connect\PoolRedis;

// 基本用法
$result = PoolRedis::call(function (Redis $redis) {
    return $redis->get('user:123');
});

// 设置值
PoolRedis::call(function (Redis $redis) {
    $redis->set('key', 'value');
    $redis->expire('key', 3600);
});

// 复杂操作
$result = PoolRedis::call(function (Redis $redis) {
    $redis->multi();
    $redis->set('key1', 'value1');
    $redis->set('key2', 'value2');
    $redis->exec();
    return true;
});
```

#### 缓存辅助方法

使用 `getSet()` 方法实现缓存穿透保护：

```php
use Swlib\Connect\PoolRedis;
use Generate\Tables\UserTable;

// 缓存数据（自动处理缓存穿透）
$user = PoolRedis::getSet(
    key: "user:profile:{$userId}",
    call: fn() => new UserTable()
        ->where([UserTable::ID => $userId])
        ->selectOne(),
    expire: 3600,           // 缓存 1 小时
    forceRefresh: false     // 是否强制刷新
);
```

**参数说明**：

| 参数 | 类型 | 说明 |
|------|------|------|
| `key` | string | 缓存键名 |
| `call` | callable | 获取数据的回调函数 |
| `expire` | int | 过期时间（秒），-1 表示随机 1-4 小时 |
| `forceRefresh` | bool | 是否强制刷新，跳过缓存直接执行回调 |

#### 缓存穿透保护

`getSet()` 方法内置了缓存穿透保护：

```php
// 如果回调返回 null 或空值，不会写入缓存
$result = PoolRedis::getSet(
    key: "search:{$keyword}",
    call: fn() => $this->searchDatabase($keyword),
    expire: 300
);

// 如果 $result 为空，下次请求会重新查询数据库
// 可以通过缓存空值来防止缓存穿透
```

#### 手动获取/归还连接

```php
use Swlib\Connect\PoolRedis;

// 手动获取连接（不推荐，建议使用 call）
$redis = PoolRedis::get();
try {
    $redis->set('key', 'value');
} finally {
    PoolRedis::put($redis);  // 必须归还连接
}
```

---

### 13.4 MySQL 连接池

#### 基本使用

框架的 ORM（Table 类）自动使用连接池，无需手动操作：

```php
use Generate\Tables\UserTable;

// 自动使用连接池
$user = new UserTable()
    ->where([UserTable::ID => 1])
    ->selectOne();
```

#### 手动使用连接池

对于需要执行原生 SQL 的场景：

```php
use Generate\DatabaseConnect;

// 使用 call 方法执行原生 SQL
$result = DatabaseConnect::call(function ($mysqli) {
    $result = $mysqli->query("SELECT * FROM users WHERE status = 1");
    return $result->fetch_all(MYSQLI_ASSOC);
});

// 指定数据库
$result = DatabaseConnect::call(function ($mysqli) {
    return $mysqli->query("SELECT COUNT(*) FROM orders");
}, 'order_db');  // 使用 order_db 数据库
```

#### 执行原生查询

```php
use Generate\DatabaseConnect;

// 简单查询
$result = DatabaseConnect::query("SELECT NOW() as current_time");

// 指定数据库
$result = DatabaseConnect::query("SELECT * FROM products", 'product_db');
```

#### 多数据库支持

```php
use Generate\DatabaseConnect;

// 获取指定数据库的配置
$config = DatabaseConnect::getConfig('slave_db');

// 获取数据库名称
$dbName = DatabaseConnect::getDbName();  // 默认返回第一个数据库

// 遍历所有数据库
DatabaseConnect::eachDbName(function ($dbName) {
    echo "Database: $dbName\n";
});

// 获取命名空间（用于代码生成）
$namespace = DatabaseConnect::getNamespace('default');
```

---

### 13.5 心跳检测

心跳检测确保连接池中的连接保持活跃，自动剔除无效连接。

#### MySQL 心跳

```php
use Swlib\Connect\MysqlHeart;

// 启动心跳（框架自动调用）
MysqlHeart::start();

// 停止心跳
MysqlHeart::stop();
```

心跳检测逻辑：
1. 定时执行 `SELECT 1` 查询
2. 如果查询成功，归还连接
3. 如果查询失败，关闭连接并归还 null

#### Redis 心跳

```php
use Swlib\Connect\RedisHeart;

// 启动心跳（框架自动调用）
RedisHeart::start();

// 停止心跳
RedisHeart::stop();
```

心跳检测逻辑：
1. 定时执行 `PING` 命令
2. 如果 PONG 响应正常，归还连接
3. 如果 PONG 响应异常，关闭连接并归还 null

---

### 13.6 连接池安全机制

#### 嵌套调用检测

框架会自动检测连接池的嵌套调用深度，防止死锁：

```php
// 危险：嵌套调用可能导致连接池耗尽
PoolRedis::call(function (Redis $redis) {
    // 外层已占用 1 个连接
    PoolRedis::call(function (Redis $redis2) {
        // 内层再占用 1 个连接
        // 如果连接池大小为 2，继续嵌套会死锁
    });
});
```

#### 嵌套深度警告

当嵌套深度超过 3 层时，框架会记录警告：

```
检测到深度嵌套的 PoolRedis 调用 (深度: 4)
这可能导致连接池耗尽，建议重构代码避免嵌套
调用栈:
  → PoolRedis::call() (file.php:10)
  → UserService::getData() (file.php:20)
  ...
```

#### 死锁保护

当嵌套深度达到或超过连接池大小时，框架会抛出异常：

```php
// 如果连接池大小为 5，嵌套 5 层会抛出异常
RuntimeException: 严重错误：检测到必然死锁！
连接池类型: PoolRedis
连接池大小: 5
当前嵌套深度: 5
原因：嵌套深度已达到或超过连接池大小，无法获取更多连接
解决方案：
  1. 增加连接池大小（建议至少 10）
  2. 重构代码，避免深度嵌套调用
  3. 检查是否有递归调用
```

#### 获取连接超时

如果获取连接超过 5 秒，框架会抛出超时异常：

```
获取 Redis 连接超时 (5.02秒)
当前连接池大小: 10
当前嵌套深度: 3
可能原因:
  1. 存在嵌套的 PoolRedis 调用（检查调用栈）
  2. 连接池配置过小（建议 >= 10）
  3. 某个操作占用连接时间过长
```

---

### 13.7 最佳实践

#### 推荐的连接池大小

```env
# 根据并发量调整
# 低并发：5-10
# 中并发：10-20
# 高并发：20-50
DB_POOL_NUM=20
REDIS_POOL_NUM=20
```

#### 避免嵌套调用

```php
// 不推荐：嵌套调用
PoolRedis::call(function (Redis $redis) {
    $userId = $redis->get('session:' . $sessionId);
    PoolRedis::call(function (Redis $redis) use ($userId) {
        return $redis->get('user:' . $userId);
    });
});

// 推荐：合并操作
PoolRedis::call(function (Redis $redis) use ($sessionId) {
    $userId = $redis->get('session:' . $sessionId);
    return $redis->get('user:' . $userId);
});
```

#### 使用缓存辅助方法

```php
// 推荐：使用 getSet
$data = PoolRedis::getSet(
    key: "cache:key",
    call: fn() => $this->fetchFromDatabase(),
    expire: 3600
);

// 不推荐：手动管理缓存
$data = PoolRedis::call(function (Redis $redis) {
    $cached = $redis->get('cache:key');
    if ($cached) {
        return unserialize($cached);
    }
    $data = $this->fetchFromDatabase();
    $redis->set('cache:key', serialize($data));
    $redis->expire('cache:key', 3600);
    return $data;
});
```

#### 强制刷新缓存

```php
// 更新数据后强制刷新缓存
public function updateUser(int $userId, array $data): void
{
    new UserTable()->where([UserTable::ID => $userId])->update($data);

    // 强制刷新缓存
    PoolRedis::getSet(
        key: "user:{$userId}",
        call: fn() => new UserTable()
            ->where([UserTable::ID => $userId])
            ->selectOne(),
        expire: 3600,
        forceRefresh: true
    );
}
```

#### 心跳间隔配置

```env
# 推荐配置
DB_HEART=10          # 每 10 秒心跳一次

# 如果数据库有连接超时限制，确保心跳间隔小于超时时间
# MySQL 默认 wait_timeout = 28800 秒（8小时）
# Redis 默认 timeout = 0（永不超时）
```

---

### 13.8 故障排查

#### 连接池耗尽

**症状**：
- 请求超时
- 出现 "获取连接超时" 异常

**排查步骤**：
1. 检查连接池大小配置
2. 检查是否有嵌套调用
3. 检查是否有长时间占用连接的操作

```php
// 排查：查看调用栈
PoolRedis::call(function (Redis $redis) {
    // 添加日志查看嵌套情况
    Log::save('Redis调用: ' . debug_backtrace()[0]['function']);
});
```

#### 连接失效

**症状**：
- 出现 "MySQL server has gone away" 错误
- Redis 操作返回 false

**解决方案**：
1. 确保心跳检测已启动
2. 检查数据库/Redis 服务状态
3. 适当增加心跳频率

#### 性能问题

**症状**：
- 响应时间变长
- 数据库连接数过高

**排查步骤**：
1. 监控连接池使用率
2. 检查慢查询
3. 优化 SQL 语句

```php
// 监控：记录连接池状态
$poolSize = ConfigEnum::REDIS_POOL_NUM;
$currentUsed = PoolRedis::$num;  // 当前使用的连接数
Log::info("Redis 连接池状态", [
    'pool_size' => $poolSize,
    'used' => $currentUsed,
    'available' => $poolSize - $currentUsed
], 'pool_monitor');
```

---

### 13.9 API 参考

#### PoolRedis

| 方法 | 参数 | 返回值 | 说明 |
|------|------|--------|------|
| `call(callable)` | $call: 回调函数 | mixed | 执行 Redis 操作 |
| `getSet(key, call, expire, forceRefresh)` | 缓存参数 | mixed | 缓存穿透保护 |
| `get()` | - | Redis | 获取连接（手动） |
| `put(redis)` | $redis: 连接 | void | 归还连接（手动） |
| `close()` | - | void | 关闭连接池 |

#### DatabaseConnect

| 方法 | 参数 | 返回值 | 说明 |
|------|------|--------|------|
| `call(callable, dbName)` | $call: 回调, $dbName: 数据库名 | mixed | 执行数据库操作 |
| `query(sql, dbName)` | $sql: SQL语句, $dbName: 数据库名 | mixed | 执行原生查询 |
| `get(dbName)` | $dbName: 数据库名 | mysqli | 获取连接（手动） |
| `put(mysqli, dbName)` | $mysqli: 连接, $dbName: 数据库名 | void | 归还连接（手动） |
| `getConfig(dbName)` | $dbName: 数据库名 | array | 获取数据库配置 |
| `getDbName(dbName)` | $dbName: 数据库名 | string | 获取数据库名称 |
| `getNamespace(dbName)` | $dbName: 数据库名 | string | 获取命名空间 |
| `eachDbName(callable)` | $call: 回调 | void | 遍历所有数据库 |
| `close()` | - | void | 关闭所有连接池 |
